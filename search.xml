<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仿App Store转场动画 Swift语言实现]]></title>
    <url>%2F2019%2F01%2F09%2F201901%2FSwiftTransition%2F</url>
    <content type="text"><![CDATA[参考文档： https://www.jianshu.com/p/d802eb2e5a31本文主体思路是参考该博主的OC版本实现的https://www.jianshu.com/p/8a99020d954f本文章介绍了转场动画中相关的一些概念，我感觉还是挺通俗易懂的。 效果图： 场景分析：1、某日，我看到App Store上首页花里胡哨的转场动画体验着实不错，便想着自己实现一番。2、作为一个萌新看到这样的效果完全联想不到是用何等操作实现的，so，百度，于是找到一个OC版。3、然后也知道此效果主要是通过重写系统的push、pop动画达到的。作为一个Swift偏好者，难免不想翻译一下。4、既然是需要push、pop，那么第一步是需要navigationController，我是直接在StoryBoard中嵌入的。5、接下来是首页TableView布局，cell触摸缩小放大。6、点击cell Push到详情页，本文重点，先放到后面再详说。7、详情页依旧是TableView布局。顶部大图为Header，底部为文本，动态计算高度即可。8、详情页伴随着左滑手势将页面按一定比例缩小，当缩小一定程度时Pop回首页。9、不难发现，在详情页左滑时还有一个模糊的背景正是首页的截图。 代码实现：除了不知道如何重写pop和push之外其余思路清晰之后，便可以开始绘制基本UI了 一、重写Push、实现Delegate123456789101112extension ViewController:UINavigationControllerDelegate,UIViewControllerAnimatedTransitioning&#123; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 1.0 &#125; func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123; return self &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; &#125;&#125; 此时我们再来仔细观察从首页点击cell之后push到详情页这之间发生了什么？不难发现，其实就是将cell放大，有一种弹出的效果，而系统的push默认效果是新页面从左边覆盖过来。 其实呢，在转场的过程中系统会提供一个视图容器用来盛装进行跳转控制器的视图，如下图所示，当前的FirstViewControllerpresent到SecondViewController的时候，此时，FirstViewController的view变成fromView，这个视图会自动加入到transtition container view中，然后在跳转过程中我们需要做的就是将SecondViewController的视图（此时是toView）加入到这个容器中，然后为这个toView的展现增加动画。以上内容摘录自此处作者：劉光軍_Shine链接：https://www.jianshu.com/p/8a99020d954f來源：简书 有了一定概念之后，我们来解读一下下面的逻辑1、拿到toView:即将要展示的视图，fromView:当前页面已展示的view2、拿到toView,fromView之后，即将要展示动画，先将fromView隐藏，操作toView的fram和alpha以达到弹出放大的效果3、将需要展示动画的view设置相应位置之后添加到transitionContext中4、展示动画toView.alpha 0~&gt;1 逐渐显示，frame 首页cell frame~&gt; 详情页header frame 逐渐放大5、移除用于展示动画的view，显示详情页view，显示首页view1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; let cell:HomeTableViewCell = tableView.cellForRow(at: selectIndexPath!) as! HomeTableViewCell let toVC:UIViewController = transitionContext.viewController(forKey: .to)! let toView:UIImageView = toVC.value(forKeyPath:"headerImageView") as! UIImageView let fromView = cell.bgView let containerView = transitionContext.containerView let snapshotView = UIImageView(image: cell.bgImageView!.image) snapshotView.frame = containerView.convert((fromView?.frame)!, from: fromView?.superview) fromView?.isHidden = true toVC.view.frame = transitionContext.finalFrame(for: toVC) toVC.view.alpha = 0 toView.isHidden = true let titleLabel = UILabel(frame: CGRect(x: 15, y: 20, width: kScreenWidth-30, height: 30)) titleLabel.textColor = UIColor.white titleLabel.font = UIFont.boldSystemFont(ofSize: 25) titleLabel.text = cell.titleLabel?.text let contentLabel = UILabel(frame: CGRect(x: 15, y: (kScreenWidth-40)*1.3-30, width: kScreenWidth-30, height: 15)) contentLabel.textColor = UIColor.white contentLabel.text = cell.contentLabel?.text contentLabel.font = UIFont(name: "PingFangSC-Light", size: 15) contentLabel.alpha = 0.5 snapshotView.addSubview(titleLabel) snapshotView.addSubview(contentLabel) containerView.addSubview(toVC.view) containerView.addSubview(snapshotView) UIView.animate(withDuration: self.transitionDuration(using: transitionContext), delay: 0.0, usingSpringWithDamping: 0.6, initialSpringVelocity: 1.0, options: .curveLinear, animations: &#123; containerView.layoutIfNeeded() toVC.view.alpha = 1.0 self.view.frame = CGRect(x: 0, y: 0, width: kScreenWidth, height: kScreenHeight) snapshotView.frame = containerView.convert(toView.frame, from: toView.superview) titleLabel.frame = CGRect(x: 22, y: 30, width: kScreenWidth - 30, height: 30) contentLabel.frame = CGRect(x: 22, y: kScreenWidth*1.3-30, width: kScreenWidth*1.3-44, height: 15) &#125;) &#123; (finished) in toView.isHidden = false fromView?.isHidden = false snapshotView.removeFromSuperview() self.tableView.reloadData() transitionContext.completeTransition(true) &#125; &#125; 二、将首页截图传递给详情页备用12345678910//MARK: 截屏 func imageFromView() -&gt;UIImage&#123; UIGraphicsBeginImageContext(self.view.frame.size) let context = UIGraphicsGetCurrentContext() self.view.layer.render(in: context!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image! &#125; 三、详情页添加左滑返回手势1、给详情页的tableView添加手势2、滑动过程中，实时获取当前滑动位置到初始位置的距离，实时计算该距离占据屏幕比例，相应缩小tableView大小并添加适应的圆角3、手势结束时，获取手势发生的开始位置，手势结束后获取结束位置，计算出总共滑动范围4、依据滑动范围所占屏幕的比例从而决定是否pop回上一页。若比例达到返回上一页，重写pop动画与push类似。若比例未达到，恢复详情页tableView frame123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@objc func handleGesture(_ sender:UIGestureRecognizer)&#123; weak var weakSelf = self switch sender.state &#123; case .began: print("手势开始---") let currentPoint = sender.location(in: self.detailTableView) startPointX = currentPoint.x startPointY = currentPoint.y isHorizontal = (startPointX &gt; CGFloat(30)) ? false : true break case .changed: print("拖动中----") let currentPoint = sender.location(in: self.detailTableView) if isHorizontal &#123; if ((currentPoint.x-startPointX)&gt;(currentPoint.y-startPointY)) &#123; scale = (kScreenWidth-(currentPoint.x-startPointX))/kScreenWidth &#125; else &#123; scale = (kScreenHeight-(currentPoint.y-startPointY))/kScreenHeight &#125; &#125; else &#123; scale = (kScreenHeight-(currentPoint.y-startPointY))/kScreenHeight &#125; if (scale &gt; CGFloat(1)) &#123; scale = CGFloat(1) &#125; else if (scale &lt;= CGFloat(0.8)) &#123; scale = CGFloat(0.8); &#125; if (self.detailTableView!.contentOffset.y&lt;=0) &#123; // 缩放 self.detailTableView!.transform = CGAffineTransform(scaleX: scale, y: scale) // 圆角 self.detailTableView!.layer.cornerRadius = 15 * (1-scale)*5*1.08; &#125; self.detailTableView!.isScrollEnabled = (scale &lt; 0.99) ? false : true break case .ended: print("手势结束--") if(scale == 0.8)&#123; DispatchQueue.main.asyncAfter(deadline: .now()+0.5) &#123; weakSelf?.navigationController?.popViewController(animated: true) &#125; &#125; self.detailTableView!.isScrollEnabled = true if scale &gt; CGFloat(0.8) &#123; UIView.animate(withDuration: 0.2) &#123; weakSelf?.detailTableView!.layer.cornerRadius = 0 weakSelf?.detailTableView!.transform = CGAffineTransform(scaleX: 1, y: 1) &#125; &#125; break default: break &#125; 总结1、如果实际开发中多处需要用到这种转场效果可以抽出一个工具类来。2、其实App Store中pop回来还有一个效果就是返回到首页时下面的文字说明会像一个抽屉一样由下往上收回的效果，有时间再去研究一下。另外，App Store上的背景配色之类一些细节处理也是非常极致的，有兴趣的朋友可以继续深究。3、如有不足之处，望各路大神斧正。4、源码地址：https://github.com/SingletonH/SwiftTransition.git]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>转场动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift3.0中函数的使用]]></title>
    <url>%2F2016%2F11%2F19%2F201611%2Fswift%2F</url>
    <content type="text"><![CDATA[前言前不久，Swift语言也更新到了3.0版本，对编程有一定基础的朋友一定不会对函数这个概念陌生。而Swift语言中的函数也是大同小异的，今天就跟着小编来学习一下Swift3中函数的不一样的用法。 1)定义一个函数以及调用12345//一，定义一个无参无返回值函数 func fun1()&#123; print(&quot;this is first function&quot;) &#125; fun1() 2)定义一个有参有返回值的函数123456func fun2(a:Int) -&gt;Int&#123; print(&quot;this is second function&quot;) return a &#125; //函数的调用 fun2(a: 2) 解析：函数的参数放在函数名后的括号中，多个参数用逗号隔开，返回值类型用连接符和一个右尖括号指明(-&gt;) 3)调用函数必须指明参数名且参数顺序不能改变123456func add1(firstNum:Int,addWithNum:Int) -&gt;Int&#123; return firstNum+addWithNum&#125;//错误案例一、add1(2,3)调用函数必须指明参数名//错误案例二、add1(addWithNum: 4 ,firstNum:add1(firstNum: 2, addWithNum: 4) 4)在使用下划线在调用函数时省略指定参数名时，调用时则必须省略参数名12345func add2(_ firstNum:Int,_ addWithNum:Int) -&gt;Int&#123; return firstNum+addWithNum&#125;//错误案例add2(2, addWithNum: 4)add2(4, 5) 5)定义函数时指定外部参数1234func add3(a firstNum:Int,b addWithNum:Int) -&gt;Int&#123; return firstNum + addWithNum&#125;add3(a: 4, b: 5)//调用时则指定外部参数名 6)声明外部参数时，不能在函数内使用外部参数进行运算，同时在调用时也不能使用内部参数赋值12345//错误案例//func add4(a firstNum:Int,b addWithNum:Int) -&gt;Int&#123;// return a + b值//&#125;//add4(firstNum: 2, addWithNum: 4) 7)在使用外部参数的情况下，不能使用下划线省略参数1234//错误案例//func add5(_ a firstNum:Int,b addWithNum:Int) -&gt;Int&#123;// return firstNum + addWithNum//&#125; 8)在定义一个带参的函数时可以给参数设置一个默认值123456func add5(firstNum:Int,addWithNum:Int = 2) -&gt;Int&#123; return firstNum+addWithNum&#125;add5(firstNum:4) //得到结果6add5(firstNum: 4,addWithNum: 6)//得到结果10 9)函数在Swift语言中是第一等类型（类似于Java中的类），意味着可以是函数的参数以及返回值12341 func outer4(f:()-&gt;Void) -&gt; (Int,Int)-&gt;(Int,Int) &#123;2 3 //......4 &#125; 备注：Swift教程持续更新中，欢迎各位学习交流。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate一对多配置]]></title>
    <url>%2F2016%2F11%2F10%2F201611%2Fonetomany%2F</url>
    <content type="text"><![CDATA[前言：在java的世界中万事万物皆对象，而在一个工程中往往是涉及到多个对象。那么在处理多个对象之间的关系显得尤为重要，对象关系大致可以分为四种。一对一、一对多、多对一、多对多，而一对一无需多讲，一对多与多对一则是考虑的角度问题，其本质都是一样的，最后多对多也是可以拆分为一对多的关系。本例讲解一个订单与订单明细的例子便属于一个典型的一对多关系。 需求：本例需要做一个饭馆管理客户小型的点餐系统，主要是管理客户订单。误区：对于面向对象编程语言的初学者来说建模时可能会定义一个订单对象包含订单编号，订单日期，订单人数，所定菜名，份数，价格等属性的一个对象。正解：此处应分为两个对象，一个订单对象（订单号，人数，日期，等）一个订单明细对象（所定菜名，份数，价格等）。因为一个对象与属性的关系应该是十分紧密的，比如说菜的价格是与菜关联的并没有与订单存在直接关系。一个客户（订单对象）可能会点多个菜（订单明细对象），这便是我们问题的引入点。 一对多配置方式一、使用jpa注解首先看一下我们one端，也就是订单对象端部分代码1234567891011121314151617181920212223242526272829303132import java.util.Date;import java.util.HashSet;import java.util.Set;import javax.persistence.CascadeType;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.FetchType;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToMany;import javax.persistence.Table;@Entity@Table(name = &quot;t_order&quot;)public class Order &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id;// 主键 @Column(name=&quot;p_Count&quot;,nullable=false) private Integer pCount;// 人数 @Column(name=&quot;pub_Date&quot;,nullable=false) private Date pubDate;//日期 private Set&lt;OrderItem&gt; orderItems = new HashSet&lt;OrderItem&gt;(); @OneToMany(mappedBy=&quot;order&quot;,cascade=&#123;CascadeType.ALL&#125;,fetch=FetchType.EAGER) public Set&lt;OrderItem&gt; getOrderItems() &#123; return orderItems; &#125; 接下是我们的 many端123456789101112131415161718@Entity@Table(name = &quot;t_order_item&quot;)public class OrderItem &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id;//主键 @Column(name=&quot;detail_desc&quot;,nullable=false,length=50) private String detailDesc;//菜名 @Column(name=&quot;price&quot;,nullable=false) private Integer price;//单价 @Column(name=&quot;c_count&quot;,nullable=false) private Integer cCount;//数量 private Order order; @ManyToOne(cascade=&#123;CascadeType.REMOVE&#125;,optional=true,fetch=FetchType.EAGER) @JoinColumn(name=&quot;orderid&quot;) 解析：hibernate主要通过onetomany和manytoone这两个注解建立起订单表与订单明细表的主外键引用关系。主表对象通过定义set集合存放从表对象，从表定义一个属性为主表对象，从而使两个对象关联起来。 一对多配置方式二、使用xml配置12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;order&quot;&gt; &lt;class name=&quot;order.entity.Order&quot; table=&quot;t_order&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;long&quot; column=&quot;ID&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;pCount&quot; type=&quot;string&quot;&gt; &lt;column name=&quot;p_Count&quot; length=&quot;15&quot;&gt;&lt;/column&gt; &lt;/property&gt; &lt;set name=&quot;orders&quot; cascade=&quot;save-update&quot; lazy=&quot;false&quot;&gt; &lt;key column=&quot;orderItem_ID&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;order.entity.OrderItem&quot;/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789&lt;hibernate-mapping package=&quot;order&quot;&gt; &lt;class name=&quot;order.entity.OrderItem&quot; table=&quot;t_orderItem&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;long&quot; column=&quot;orderItem_ID&quot;&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/id&gt; ... &lt;many-to-one name=&quot;customer&quot; column=&quot;CUSTOMER_ID&quot; class=&quot;order.entity.Order&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 总结：java程序中的对象，数据库中的表，这两者在设计中往往存在不同步状况，建好一个项目中的模显得尤为重要。]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate UUID问题]]></title>
    <url>%2F2016%2F11%2F03%2F201611%2Fuuid%2F</url>
    <content type="text"><![CDATA[前言hibernate对于字符串类型主键支持UUID主键生成策略，(号称是世界上唯一的字符串)运行环境：运行环境：hibernate5.2，mysql5.6。 一，使用hibernate给String类型id设置uuid的两种方式①，注解 @GeneratedValue(generator = “uuid”) @GeneratedValue(generator = “uuid”) @GenericGenerator(name = “uuid”, strategy = “uuid”) ②，配置文件 备注：通过这两种方式都可以给String类型id设置uuid，由hibernate自动生成一个id值插入数据库。如果在数据库直接插入数据则必须传入主键id，未经过hibernate是不会生成id的。 二，根据uuid操作对象时应注意的问题由于主键id为字符串类型，在做数据库操作(增删改查)时id必须用单引号引用，否则失败。 id值没有使用单引号引用，并且我们在没有使用hibernate给我们自动生成uuid时，自己手动插入较短的id时，mysql具有一定的兼容性，操作正常。]]></content>
      <categories>
        <category>易错笔记</category>
      </categories>
      <tags>
        <tag>易错笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈系统架构]]></title>
    <url>%2F2016%2F10%2F31%2F201610%2Fframework%2F</url>
    <content type="text"><![CDATA[前言博主刚刚从事于Web后端开发与学习不久，开发项目经验也是有限的。不过今天依旧将一些个人的想法记录下来，我的构想或许不太正确，还望各位大牛能给我多多建议。 我们从编程开始讲起 博主是偏向于后端开发的程序员，从入门到如今，学过的语言，技术为数不多。但我敢肯定的是：无论是哪一门语言，其语法只要是一个有正常逻辑思维能力的人再加上他一定时间的研究学习。弄懂这门语言的语法是没有任何问题的。那么问题来了。在学过那么多编程语言后，又有多少人能够深刻理解编程过程中涉及到的编程思想。也就造成一部分人在学习过程中知道一个需求该怎么写，但从来没有思考过为什么需要这样写。因此，我在学习一门语言中，常是会问自己，这样写的好处是什么，坏处又有什么，益处也是颇多。 Next: 谈谈需求分析 需求分析对于一个项目来说应该是重中之重，这直接影响到一个项目的成败。而需求分析之前往往还需要通过大量准确的市场调研，毕竟我们最终开发的东西是需要为人民服务，给我们带来便利的。在通过一帮子人不停的讨论、分析，最终将需求报告总结出来之后，又有一个重要的部分需要完成。那便是是项目建模以及权限分配等等，这些模型作为一个项目的分子级别的存在同样是不能容忍存在任何差异的。 Then: 异常处理 无论一个多大多小的项目一定会存在或多或少的bug，如果不存在反而这个项目是存在问题的。在我们代码的编写过程中应当考虑任何有可能发生异常的情况，并给出相应的处理方案。例如，服务器突然发生异常，用户的不正当操作，亦或是用户的并发操作等都有可能给我们的项目带来各种各样的问题。引用伟人说过的一句话——我们不能规避误差，但可以规避错误。方向上的东西一定不允许出错，细节上的尽量规避。而对于比较重要的连环操作更是应当引入事务的支持，例如银行转账，A给B转账1000，先从A账户的余额判断是否大于1000，再减去1000，之后再在B账户的余额增加1000.（实际过程肯定更加严谨）如果在A账户转出成功后，B账户转入失败了呢。这一系列操作应当要回滚。顾对于一个项目重要的部分应添加事务的支持，要么这一些连环操作都执行成功，要么执行失败，回退到执行之前的状态。 Latter: 框架的使用 在一个项目中或多或少需要引用各种各样的框架使我们的项目更加强健，稳固。同时，我们也不能过分依赖于框架，使我们的项目过分的与框架耦合在一起。假如，我们发现在我们项目中某套框架存在很大的漏洞，又或者是有一套全新的更加完善的框架出现，需要替换框架时，此时我们才发现我们的代码与框架已经紧密耦合在一起了。这个时候如需要替换的话，对我们的成本来说无疑是巨大的打击。例如，在web后端中常用的一套框架spring，如果我们在代码中总是使用spring的注解，而抛弃xml文件可能就会造成这样的问题。 Last:前后端分离随着互联网的高速发展，以及移动设备的普及，我们的项目更是要适应多平台的使用。在我们的后端代码中更是不能与我们前端页面出现紧密耦合，此时不防使用SOA(面向服务体系架构)思想。这里我分享一位大牛(@夏天的森林)对于前后端分离的博客__Web应用架构的新趋势 总结这是属于本人从一个专业角度并不是非常成熟的角度分析的成果，有何不对的地方，望各位指正。]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用反射手写代码实现spring AOP]]></title>
    <url>%2F2016%2F10%2F31%2F201610%2Fspring_aop_m%2F</url>
    <content type="text"><![CDATA[前言本篇博客我们继续深入spring，还是在原有的基础上进行改造。下面请先欣赏一下博主画的一张aop简图（没有艺术天分，画的不好莫见怪） 解析：往往在我们的系统的多个核心流程中会有一部分与之关系不大的相同的横切流程，例如权限认证，事务管理。因此我们一般会抽象出这些相同的比较次要的交给spring aop的Handler来统一处理这些横切流程也就是上图中绿色部分。接下来我们看一下本例结构图：解析：1，我们的Hostess对象是Master接口的实现，主要实现了WalkDog()和shopping()两个方法，而WalkDog()方法则是调用的是Dog接口的实现类的bark()方法。2，我们整个程序的入口Client调用的Hostess对象的两个核心方法，HumanHandler处理的Hostess对象的横切流程。1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Master master = (Master)context.getBean(&quot;humanProxy&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;&quot;); master.shopping(); master.WalkDog(); &#125;&#125; 123456789101112131415161718192021222324package human;import dog.Dog;public class Hostess implements Master &#123; private Dog dog; public void setDog(Dog dog) &#123; this.dog = dog; &#125; @Override public void WalkDog() &#123; dog.bark(); &#125; @Override public void shopping()&#123; System.out.println(&quot;疯狂购物中&quot;); &#125;&#125; 解析：通过以上代码我们不难发现我们的程序只是调用核心业务，而往往核心业务的周围有很多繁琐的相对于比较次要的横切业务。利用本例中遛狗，购物之前，我们需要再家做一些前提准备。例如：整理一下着装，锁上房门等等，回家之后有需要换鞋之类的。因此我们还需要一个handler来处理这些业务。1234567891011121314151617181920212223242526272829303132333435363738394041424344package aop;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class HumanHandler implements InvocationHandler &#123; private Object target;// 目标是不固定 public void setTarget(Object target) &#123; this.target = target; &#125; /* * return 返回是原来目标方法所返回的内容 method 就是要执行的方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub before(); // 具体的业务逻辑代码 Object returnValue = method.invoke(target, args); after(); return returnValue; &#125; private void before() &#123; // 前置任务 System.out.println(&quot;[代理执行前置任务]整理着装&quot;); System.out.println(&quot;[代理执行前置任务]带上钥匙&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;[核心业务开始]*****************&quot;); &#125; private void after() &#123; // 后置任务 System.out.println(&quot;[核心业务结束]*****************&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;[代理执行后置任务]开门&quot;); System.out.println(&quot;[代理执行后置任务]换鞋&quot;); &#125;&#125; 解析：有了handler我们还需要一个代理工厂1234567891011121314151617181920212223242526package org.springframework.aop.framework;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class ProxyFactoryBean &#123; private Object target; private InvocationHandler handler; public ProxyFactoryBean(Object target,InvocationHandler handler)&#123; this.target = target; this.handler = handler; &#125; //返回本类的一个实例 public Object getProxyBean() throws IllegalArgumentException, InstantiationException, IllegalAccessException, ClassNotFoundException&#123; Object obj = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); return obj; &#125;&#125; 解析：接下来我们来看一下本例的具体配置123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt; &lt;bean id=&quot;hostess&quot; class=&quot;human.Hostess&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dog1&quot; class=&quot;dog.Taidi&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;dog2&quot; class=&quot;dog.Labuladuo&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;humanHandler&quot; class=&quot;aop.HumanHandler&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;hostess&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;humanProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;handlerName&quot; ref=&quot;humanHandler&quot;&gt;&lt;/property&gt; &lt;property name=&quot;target&quot; ref=&quot;hostess&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 最后一步也是关键，本类中使用到的实例需要我们通过读取上面这份配置文件然后通过反射构造出来。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package aop;import java.io.File;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.springframework.aop.framework.ProxyFactoryBean;public class ClassPathXmlApplicationContext implements ApplicationContext &#123; private String fileName; public ClassPathXmlApplicationContext(String fileName)&#123; this.fileName = fileName; &#125; @Override public Object getBean(String beanid) &#123; System.out.println(&quot;传递过来的ID:&quot;+beanid); //获取本类的当前目录 String currentPath = this.getClass().getResource(&quot;&quot;).getPath().toString(); SAXReader reader = new SAXReader();//DOM4J解释器 Document doc = null;//xml文档本身 Object obj = null;//目标表创建出来的实例 try &#123; doc = reader.read( new File(currentPath+fileName) ); String xpath = &quot;/beans/bean[@id=&apos;&quot;+beanid+&quot;&apos;]&quot;; Element beanNode = (Element) doc.selectSingleNode(xpath); String className = beanNode.attributeValue(&quot;class&quot;); if (&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;.equals(className))&#123; Element interceptorNamesNode = (Element) beanNode.selectSingleNode(&quot;property[@name=&apos;handlerName&apos;]&quot;); String handlerName_value = interceptorNamesNode.attributeValue(&quot;ref&quot;); Element targetNode = (Element) beanNode.selectSingleNode(&quot;property[@name=&apos;target&apos;]&quot;); String targetName_value = targetNode.attributeValue(&quot;ref&quot;); return forProxyFactoryBean(targetName_value,handlerName_value); &#125; obj = Class.forName(className).newInstance(); //查找下一代 Element propertyNode = (Element) beanNode.selectSingleNode(&quot;property&quot;); if (propertyNode!=null)&#123; //注入 //System.out.println(&quot;发现property节点，准备注入&quot;); //需要注入的属性名 String propertyName = propertyNode.attributeValue(&quot;name&quot;); //System.out.println(&quot;需要注入的属性：&quot;+propertyName); //注入方法 String executeMethod = &quot;set&quot;+(propertyName.substring(0, 1)).toUpperCase()+propertyName.substring(1,propertyName.length()); //System.out.println(&quot;需要执行注入方法：&quot;+executeMethod); //需要注入的对象实例 String di_object_name = propertyNode.attributeValue(&quot;ref&quot;); //System.out.println(&quot;注入的对象是：&quot;+di_object_name); //定义我们的需要注入的对象实例[递归算法：1.层级是不知道多少层的 2.自己调用自己 3.最后1层会自己结束] Object di_object = getBean(di_object_name); //System.out.println(&quot;xxx:&quot;+di_object); //Method method = obj.getClass().getMethod(executeMethod,di_object.getClass().getInterfaces());// new Method(executeMethod); Method []methods = obj.getClass().getMethods(); for (Method m : methods) &#123; if(executeMethod.equals(m.getName()) ) &#123; m.invoke(obj, di_object); break; &#125; &#125; &#125; else&#123; System.out.println(&quot;没有属性，结束即可&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;返回实例：&quot;+obj); return obj; &#125; public Object forProxyFactoryBean(String targetName_value,String handlerName_value) throws Exception&#123; System.out.println(&quot;目标对象&quot;+targetName_value); Object target = getBean(targetName_value); System.out.println(&quot;代理对象&quot;+handlerName_value); InvocationHandler handler = (InvocationHandler) getBean(handlerName_value); return new ProxyFactoryBean(target,handler).getProxyBean(); &#125;&#125; 运行结果如下: 总结1 spring aop将我们的系统分为两部分，一核心业务，二横切业务。我们的只需关注核心业务，横切业务统一交给代理去处理。2 本例依旧是利用反射调用横切方法实现aop，还是那句话，我们自己写的自然是漏洞百出，只是为了说明问题。作为一个开源的框架，如果对spring源码感兴趣的朋友可以自行查看。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手编写spring IOC源码]]></title>
    <url>%2F2016%2F10%2F31%2F201610%2Fspring_ioc_m%2F</url>
    <content type="text"><![CDATA[前言对于spring IOC概念不是很了解的朋友可以阅读我上一篇博客__轻松理解spring IOC 通过这篇博客的理解之后，相信大家会对spring的IOC概念会有进一步的理解。接下来我先预览一下本例中java的类图关系。解析：我们有一个Master接口，接口中定义了一个WalkDog()遛狗的方法，Hostess是对这个接口的具体实现。然后我们有一个Dog接口，接口中有一个bark()方法，Labuladuo和Taidi是对其的实现。最后我们的程序入口Client类调用Hostess对象的WalkDog方法。需求：Hostess对象遛狗需要一个狗对象，目前我们的类中有两个符合需求的对象，我们只要在配置文件中进行相关配置便可以指定我们的Hostess对象调用的是哪一个具体的Dog对象。12345678910public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Master master = (Master)context.getBean(&quot;hostess&quot;); System.out.println(); System.out.println(); System.out.println(); System.out.println(&quot;***********************************&quot;); master.WalkDog(); &#125; 解析：从main方法的前两句原spring的代码中我们可以猜想，spring框架中一定是定义了ApplicationContext这个接口，并且接口中定义了一个getBean()的方法，而ClassPathXmlApplicationContext类肯定是对其的实现。既然是我们自己动手写spring框架，我们把这个接口和类实现了也就可以了。 接口 ApplicationContext public interface ApplicationContext { public Object getBean(String beanid); } 实现类 ClassPathXmlApplicationContext package com; import java.io.File; import java.lang.reflect.Method; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.Node; import org.dom4j.io.SAXReader; public class ClassPathXmlApplicationContext implements ApplicationContext { private String fileName; public ClassPathXmlApplicationContext(String fileName){ this.fileName = fileName; } @Override public Object getBean(String beanid) { //获取本类的当前目录 String currentPath = this.getClass().getResource(&quot;&quot;).getPath().toString(); SAXReader reader = new SAXReader();//DOM4J解释器 Document doc = null;//xml文档本身 Object obj = null;//目标表创建出来的实例 try { doc = reader.read( new File(currentPath+fileName) ); String xpath = &quot;/beans/bean[@id=&apos;&quot;+beanid+&quot;&apos;]&quot;; Element beanNode = (Element) doc.selectSingleNode(xpath); String className = beanNode.attributeValue(&quot;class&quot;); obj = Class.forName(className).newInstance(); Element propertyNode = (Element) beanNode.selectSingleNode(&quot;property&quot;); if(propertyNode!=null){ System.out.println(&quot;当前bean有属性需要注入&quot;); String propertyName = propertyNode.attributeValue(&quot;name&quot;); System.out.println(&quot;当前bean需要注入的属性为&quot;+propertyName); //拼接出注入方法 String setMethod = &quot;set&quot;+(propertyName.substring(0, 1)).toUpperCase()+propertyName.substring(1,propertyName.length()); System.out.println(&quot;自动调用注入方法&quot;+setMethod); String set_object_name = propertyNode.attributeValue(&quot;ref&quot;); System.out.println(&quot;需要注入的对象名&quot;+set_object_name); Object di_object = getBean(set_object_name); System.out.println(&quot;注入的对象实例&quot;+di_object); Method []methods = obj.getClass().getMethods(); for (Method m : methods) { if(setMethod.equals(m.getName()) ) { m.invoke(obj, di_object); break; } } }else{ System.out.println(&quot;当前bean没有属性，无需注入直接结束&quot;); } } catch (Exception e) { e.printStackTrace(); } return obj; } } 配置文件 applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans&gt; &lt;bean id=&quot;hostess&quot; class=&quot;com.Hostess&quot;&gt; &lt;property name=&quot;dog&quot; ref=&quot;Taidi_dog&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;Taidi_dog&quot; class=&quot;com.Taidi&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;Labuladuo_dog&quot; class=&quot;com.Labuladuo&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 解析：① 我们的applicationContext.xml文件主要是配置我们的java bean。这里我们自己写一份这样的文件通知我们自己的框架有哪些对象需要注入。② 接口 ApplicationContext 这里我只是定义了一个方法就不多解释了。③ 实现类 ClassPathXmlApplicationContext 主要是解析我们的xml文件然后构造实例的一个类。解析xml文件我们主要使用的是dom4j，获取各个节点和节点属性与属性值。创建对象则是通过反射的方式构造对象 [obj = Class.forName(className).newInstance();]。 在判断一个对象是否有属性需要注入则是使用递归算法对其一一注入。 最后： 我们来看一下运行结果 总结我们自己手写的框架自然没有spring框架严谨，安全(不然它早倒闭了)，不过spring的原理我们自己的也是大同小异的。通过源码级别的解读，相信大家已经可以熟练掌握IOC原理。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中SSH三大框架环境搭建]]></title>
    <url>%2F2016%2F10%2F31%2F201610%2Fssh01%2F</url>
    <content type="text"><![CDATA[前言这里先简单介绍一下我使用的三大框架版本以及下载地址struts-2.3.30下载spring-framework-4.3.1下载hibernate-release-5.2.2下载 第一步：创建工程将上面的jar包下载解压完成后，先在eclipse中新建一个web工程，新建工程的同时最好选上创建的同时添加web.xml文件 第二步：导入jar包找到下载并解压好的strtus文件中找到apps目录下的strtus2-blank.war的压缩包，再找到这个压缩包中WEB-INF目录下的lib目录，最后将lib中的所有jar包复制到我们新建项目的lib包中 第三步：配置web.xml文件找到前面lib包所在的同级目录下的web.xml文件，复制出其配置的过滤器，如下：注意：由于struts版本不同所以其配置的过滤器写法上略有差异，我们一般参照官方给的模板1234567891011&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 第四步：编写源码我们可以写我们的action类了，编写action类我们一般会继承ActionSupport父类在aciton类中我们可以定义一个返回值为String类型的execute()方法[该方法为默认方法]。这里的action我们可以简单理解为MVC模式下的控制器123456789101112import com.opensymphony.xwork2.ActionSupport;public class IndexAction extends ActionSupport&#123; @Override public String execute()&#123; System.out.println(&quot;该方法为默认方法被struts2自动调用&quot;); return &quot;success&quot;; &#125;&#125; 第五步：配置strtus.xml文件我们需要配置一个非常重要的struts.xml文件，我们还是找到前面lib包所在同级目录下的src目录下的java目录下的struts.xml文件将xml文件头信息复制出来，如下：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;001pck&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;Index&quot; class=&quot;action.IndexAction&quot; method=&quot;execute&quot;&gt; &lt;result name=&quot;success&quot;&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 这里package标记中name属性用作定义一个包名以区分其他人代码,extends属性用于继承一个父包 action标记中的name属性是用作客户端访问时的路径相当于Servlet’s path action标记中的class属性则是用作与这个action所对应的aciton类的全路径 action标记中的method属性时与action类的方法所对应不写默认为execute方法 action标记内result中的name属性为其父标记所对应方法的返回值，不写默认为success 若返回值与name属性值匹配则完成result标记内指定的路径进行跳转(本例就跳转到我们事先编写好的一个index.jsp页面) 第六步：运行项目此时我们发现我们的请求已经被struts成功拦截，接下来我们输入我们正确的访问路径也就是我们上一步配置action中name属性的值]]></content>
      <categories>
        <category>SSH框架整合</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spring类注解简化配置]]></title>
    <url>%2F2016%2F10%2F31%2F201610%2Fspring_rsce%2F</url>
    <content type="text"><![CDATA[前言xml文件以及注解都可以对我们java源文件起到辅助支持的作用，本例针对于@Controller @Service @Repository这四个spring的类注解进行详细讲解。首先：我们浏览一下我们原始的applicationContext.xml中的部分配置。 1234567891011&lt;bean id=&quot;myNewsAction&quot; class=&quot;news.action.NewsAction&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;ns&quot; ref=&quot;myNewsService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myNewsService&quot; class=&quot;news.service.NewsServiceImpl&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;nd&quot; ref=&quot;myNewsDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myNewsDao&quot; class=&quot;news.dao.NewsDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;sf&quot; ref=&quot;mySessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 解析：当一个项目中所涉及到的java bean十分庞大，而每一个bean中的配置都是大同小异的，那么这份applicationContext.xml文件显得有些冗杂。 第一步简化12345&lt;bean id=&quot;myNewsAction&quot; class=&quot;news.action.NewsAction&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myNewsService&quot; class=&quot;news.service.NewsServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myNewsDao&quot; class=&quot;news.dao.NewsDaoImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 解析：在配置文件中只需申明这个bean，然后在源文件中添加@Autowired，@Qualifier这两个注解。数据层SessionFactory属性注入详情如下：123@Autowired@Qualifier(&quot;mySessionFactory&quot;)private SessionFactory sessionFactory; 解析：在@Qualifier这个注解中我们指定其引用的是哪一个bean，spring便会自动为其注入这个实例，并且属性的set方法也可省略但是：经过上面的一番操作仿佛没有给我省多少事，别急，精华总是留在最后。 第二步简化123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt; &lt;!-- 基于news这个包自动扫描其中的类 ,也会自动注入解析器--&gt; &lt;context:component-scan base-package=&quot;news&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;bean id=&quot;mySessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; 解析：从这份applicationContext.xml文件中我们可以明显的看到并没有给我们的java bean进行相关配置，只是配置了一些基本的数据源。唯一多了一行:1&lt;context:component-scan base-package=&quot;news&quot;&gt;&lt;/context:component-scan&gt; 通过这个节点的base-package属性可以配置spring需要自动注入的哪个基包。此时便是spring的@Controller @Service @Repository这三个注解起作用的时候了。1234567@Controller(&quot;myNewsAction&quot;)@Scope(&quot;prototype&quot;)public class NewsAction extends ActionSupport &#123; @Autowired @Qualifier(&quot;myNewsService&quot;) private NewsService ns; 1234567@Service(&quot;myNewsService&quot;)@Scope(&quot;prototype&quot;)public class NewsServiceImpl implements NewsService &#123; @Autowired @Qualifier(&quot;myNewsDao&quot;) private NewsDao nd; 1234567@Repository(&quot;myNewsDao&quot;)@Scope(&quot;prototype&quot;) public class NewsDaoImpl implements NewsDao &#123; @Autowired @Qualifier(&quot;mySessionFactory&quot;) private SessionFactory sf; 解析：①，注解@Controller为我们的控制器action类的类注解相当于applicationContext.xml文件中的bean节点，而括号中的值相当于bean节点中的id属性的属性值。同理：@Service为我们业务层的类注解，@Repository为数据层dao的类注解。②，注解 @Scope(“prototype”) 相当于applicationContext.xml文件中bean节点中scope属性，这个非单例模式注解十分重要，主要起到线程安全，防止并发操作时出现异常的作用。 小结使用spring的类注解和属性注解确实能给我们带来许多便利，关于类属性的注解其实jdk javax.annotation.Resource包中便有@Resource注解。所以，我们当然也可以选择使用jdk的注解，不过要注意的是，千万不要把jdk的注解和spring的注解混用。在软件系统中，由于原生的jdk难免存在一些缺陷，我们在开发过程中往往需要引入各种框架，因此我们的项目便不得不与这些框架耦合在一起。虽然我们一直不希望我们的代码出现耦合，毕竟这只是一种理想状态。总之，轻度耦合一直是我们追求的代码风格。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中SSH三大框架环境搭建]]></title>
    <url>%2F2016%2F10%2F30%2F201610%2Fssh03%2F</url>
    <content type="text"><![CDATA[前言通过上两篇文章我们已经可以掌握struts2和spring的环境的搭建以及简单使用，但是在访问数据库层面使用的是传统的JDBC。在我们项目开发中使用JDBC确实是不太理想的，所以今天我给大家来讲解一下目前行业中比较流行的持久层框架——hibernate。 相关链接eclipse中SSH三大框架环境搭建&lt;一&gt;eclipse中SSH三大框架环境搭建&lt;二&gt; 第一步：需要引入hibernate的jar包找到hibernate解压好的文件目录，在该目录下的lib目录下有一个required目录，将该目录下的所有jar包引入到我们项目的lib目录下。 第二步：配置实体映射文件首先我们要配置一个在src目录下的一个实体映射文件entityname.hbm.xml。(后期可以使用注解替代)12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;entity.BookCard&quot; table=&quot;BookCard&quot;&gt; &lt;id name=&quot;cid&quot; column=&quot;cid&quot;&gt;&lt;/id&gt; &lt;property name=&quot;name&quot; column=&quot;name&quot; type=&quot;string&quot; length=&quot;50&quot; not-null=&quot;true&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cardDate&quot; column=&quot;cardDate&quot;&gt;&lt;/property&gt; &lt;property name=&quot;deposit&quot; column=&quot;deposit&quot;&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 解析：1&gt;头信息就不多说了，首先写好一个hibernate-mapping首尾标记，在标记内映射我们相对应的实体类。2&gt;在class标记的name属性的值对应我们的实体类(全路径)，table属性对应我们在数据库的表名3&gt;id标记为我们数据库的主键配置相关信息，同理name属性中的属性值为我们实体类对象的属性，column为数据库对应表的字段。4&gt;property标记中type属性为该属性对应的java数据类型，length为数据库中指定长度这里相当于varchar(50)，not-null属性为指定该字段是否可以为空，默认可以为空。 第三步：依旧是写配置文件，配置连接数据库相关信息的hibernate.cfg.xml文件1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory name=&quot;foo&quot;&gt; &lt;!-- 配置mySql连接参数 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;property name=&quot;connection.pool_size&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/CardDB&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;mapping resource=&quot;BookCard.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 解析：1&gt;配置一个hibernate-configuration首尾标记，在其内部插入session-factory首尾标记。2&gt;在property标记中name属性中指定dialect属性值配置数据库方言(数据库不同以及版本不同方言也不同，查阅相关资料可知)3&gt;在property标记中name属性中指定connection.pool属性值配置连接池大小(依据访问频率配置)4&gt;在property标记中name属性中指定show_sql属性值配置是否显示sql语句在控制台(开发过程中建议为true，易于调试)5&gt;在property标记中name属性中指定format_sql属性值配置sql语句是否需要格式化(废话，当然要) 6&gt;在property标记中name属性中指定hbm2ddl.auto属性值配置创表信息。值为update时，若数据库没有我们实体对应的表将自动为我们创建，若存在则会更新我的表。 值为create时，每次执行时会先查找数据库是否存在这张表存在即先删除在创建，不存在即直接创建。7&gt;连接数据库的驱动以及制定数据库URL，用户名和密码相信大家都懂，我就不一一介绍了。 8&gt;我们的这份文件还需映射一个资源便是我们的实体映射文件，在mapping标记中指定。 第四步：编写数据访问层dao12345678910111213141516171819public class BookCardDaoImpl implements BookCardDao &#123; @Override public List&lt;BookCard&gt; getAllCardInfo() &#123; //sessionFactory这个实例可以自己按常规的hibernate传统写法创建(不建议) //可以交给spring去托管 SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.openSession(); //后面当使用JPA的时候，EntityManager 类似于 Session Query query = session.createQuery(&quot;from BookCard&quot;); //这2行代码，后期会交给spring的AOP帮忙处理 List&lt;BookCard&gt; list = query.getResultList(); session.close(); sessionFactory.close(); return list; &#125;&#125; 解析：通过上面的代码我们可以明显看出hibernate的实用性，我们的程序员再也不用写获取连接，获取sql语句的执行对象等等，以及在代码中我们都不需要关心该项目使用的是哪一个数据库了，如此一来大大提高了我们的工作效率。下图为控制台hibernate打印的日志]]></content>
      <categories>
        <category>SSH框架整合</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松理解spring IOC]]></title>
    <url>%2F2016%2F10%2F30%2F201610%2Fspring_ioc%2F</url>
    <content type="text"><![CDATA[spring IOC概念spring IOC(Inversion of control)即控制反转，spring框架的核心之一。控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系。 接下来我们以一个数据库连接的案列来阐述IOC的工作原理，下图为该项目的结构体系解析：action层为我们的控制层，service层为业务逻辑层，dao为数据访问层，util包为提供数据库连接对象的辅助层，entity为本例的实例层。关键dao层可以自由，便捷操作mysql和sqlserver数据库 第一步：我们先定义获取连接对象的接口1234567package util;import java.sql.Connection;public interface MyConnection &#123; public Connection getConnection();&#125; 第二步：提供mysql和sqlserver连接对象(以sqlserver为例)123456789101112131415161718192021222324252627282930package util;import java.sql.Connection;import java.sql.DriverManager;public class MyConnection_sqlserver implements MyConnection &#123; 9 // 第一步：获取数据连接，让appliction server能够与db server进行交互 private String driver = &quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;; private String url = &quot;jdbc:sqlserver://localhost:1433;DatabaseName=CardDB&quot;; private String name = &quot;sa&quot;; private String pwd = &quot;123456&quot;; private Connection conn = null; @Override public Connection getConnection() &#123; try &#123; Class.forName(driver); &#125; catch (ClassNotFoundException e) &#123; System.out.println( e.getMessage() ); &#125; try&#123; conn = DriverManager.getConnection(url, name, pwd); &#125; catch(Exception e)&#123; System.out.println(&quot;获取数据库连接时有异常：&quot;+e.getMessage()); &#125; return conn; &#125;&#125; 第三步 dao层获取连接对象123456789101112131415161718package dao;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import entity.BookCard;import util.MyConnection;public class BookCardDaoImpl implements BookCardDao &#123; private MyConnection c; public void setC(MyConnection c) &#123; this.c = c; &#125; 解析：一，在dao中我们只定义了一个连接对象的属性，我们并不用知道具体是哪一个数据库的连接，只需要利用这个对象进行数据库操作即可 二，需要在本类中提供一个公共的set方法以便spring将这个连接对象注入进来我们可以对照面向对象编程的写法来进一步了解IOC的长处123public class BookCardDaoImpl implements BookCardDao &#123; MyConnection c = new MyConnection_sqlserver(); 解析：在传统面向对象的编程中我们层层级之间的关系紧密耦合在一起这就可能会引起这样一个问题，如果某一层出现问题，则可能影响到其他层，所以迫使其它层也需要作出调整 第四步 spring注入123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt; &lt;bean id=&quot;myDao1&quot; class=&quot;dao.BookCardDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;c&quot; ref=&quot;myConnection1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myConnection1&quot; class=&quot;util.MyConnection_mysql&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myConnection2&quot; class=&quot;util.MyConnection_sqlserver&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 解析：一，以上为部分spring的配置文件 二，回到本例的需求上来分析，如果我们需要操作mysql数据库只需要在dao这个bean中引用bean_id为myConnection1的bean，同理SqlServer则引用myConnection2 本篇博客到此结束，如果想继续深入理解IOC的朋友欢迎大家阅读下篇自己动手写spring IOC框架]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解spring AOP]]></title>
    <url>%2F2016%2F10%2F30%2F201610%2Fspring_aop%2F</url>
    <content type="text"><![CDATA[概念AOP(Aspect-Oriented Programming)即面向切面编程。它是对传统的OOP(面向对象)编程的一种补充，在OOP中往往一个对象有什么行为我们就定义什么方法,对象与对象之间存在紧密联系。与OOP不同的是AOP更加关注的是切面，我们只需要关注于对象的核心业务而不是所有的业务。 解析：如同上图1中所示，两个螺丝就是一种紧密耦合的关系， 一旦一方存在问题，另一方也必须做出相应调整。而图2为一个笔记本的USB插口，只要符合这个接口的设备都可以使用这个插口。在程序中也和现实生活一样，使用spring AOP就是一种典型的非耦合案例，AOP的核心之一就是我们的非核心业务与我们的核心业务解耦。具体实现：(本例我们模拟一个女孩子的日常生活，去KFC，约会，遛狗几个事务.PS:不会有女孩子看到这篇博客吧…) 第一步：直入主题，构造核心业务12345678910111213141516171819202122232425262728293031323334package aop_demo;/* * */public class Girl1 implements Girl&#123; private Dog dog = null; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public void KFC(String datetime)&#123; System.out.println(&quot;[核心业务逻辑]我是第一个女孩&quot;); System.out.println(&quot;[核心业务逻辑]&quot;+datetime+&quot;吃肯德基&quot;); &#125; public void meet(String datetime)&#123; System.out.println(&quot;[核心业务逻辑]我是第一个女孩&quot;); System.out.println(&quot;[核心业务逻辑]&quot;+datetime+&quot;约会&quot;); &#125; @Override public void playDog() &#123; dog.bark(); &#125;&#125; 解析：由上段代码可以看到这个例子中没有出现任何其他非业务逻辑代码，因此在一个程序中我们在多个流程中反复出现的一些非核心代码抽取出来由代理给我们管理。我们发现这几个事务之前我们的对象(女孩子)都要洗澡，化妆……之后都要卸妆….这些非逻辑业务便是我们需要分离出来的。 第二步：使用代理统一管理非逻辑业务解析：上图中的通知其本质也就是代理，由于本例中前后都有非核心业务，因此我们选择环绕通知1234567891011121314151617181920212223242526272829303132package aop_demo;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;public class AroundAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; //前置业务 System.out.println(&quot;[代理执行前置]洗澡&quot;); System.out.println(&quot;[代理执行前置]化妆&quot;); System.out.println(&quot;[代理执行前置]穿衣服&quot;); System.out.println(&quot;*****************&quot;); //核心业务 Object result = invocation.proceed(); //后置业务 System.out.println(&quot;*****************&quot;); System.out.println(&quot;[代理执行后置]卸妆&quot;); System.out.println(&quot;[代理执行后置]洗澡&quot;); System.out.println(&quot;[代理执行后置]听歌&quot;); System.out.println(&quot;&quot;); return result; &#125;&#125; 第三步：配置applicationContext.xml文件(部分)123456&lt;bean id=&quot;aroundAdvice&quot; class=&quot;aop_demo.AroundAdvice&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;girlProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;aroundAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;target&quot; ref=&quot;girl&quot;&gt;&lt;/property&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中SSH三大框架环境搭建]]></title>
    <url>%2F2016%2F10%2F30%2F201610%2Fssh02%2F</url>
    <content type="text"><![CDATA[前言通过上一篇博客我们可以轻松搭建strtus2的环境，接下来由我来继续介绍spring的环境搭建以及spring注入的简单使用 相关链接eclipse中SSH三大框架环境搭建&lt;一&gt;eclipse中SSH三大框架环境搭建&lt;三&gt;本例业务需求:将数据库一张表的信息通过JDBC查询出来并显示在页面中 流程：action控制层–&gt;service业务层–&gt;dao数据层–&gt;数据库 第一步：我们还是需要加入spring开发中所需要的jar包 找到下载并解压好的spring文件，然后找到该文件下的libs目录下文件，我们可以将所有jar包复制到我们web项目下的lib目录下注意：1&gt;.javadoc.jar文档和.sources.jar源码我们可以不拷贝到我们的项目中，如果想加深自己的理解小编建议大家看看源码(毕竟这是第一手资料) 2&gt;我们还需要加入commons-logging.jar包。用来记录程序运行时的活动的日志记录。该文件在struts2文件中app目录下的struts2-showcase.war包目录下的WEB-INF下的lib中3&gt;我们还需要加入struts2中的一个插件包struts2-spring-plugin-2.3.30.jar(经常容易忘记)4&gt;由于本例我们还需要操作mySql数据库因此还需加入数据库驱动包mysql-connector-java-5.1.39-bin.jar 第二步：由于本例用到了struts所以还是需要先配置strtus.xml文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;!-- 告知Struts2运行时使用Spring来创建对象 --&gt; &lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&gt; &lt;package name=&quot;001pck&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;Index&quot; class=&quot;myIndexAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 注意：这里的class并没有引用一个具体的类而是取了一个别名，接下来再由spring给它注入 第三步：配置applicationContext.xml文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt; &lt;!-- 类似于财务部门一样，类就是钱，所有需要类的实例都由srping去管理, pojo除外--&gt; &lt;bean id=&quot;myIndexAction&quot; class=&quot;action.IndexAction&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;index&quot; ref=&quot;myService1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- index = new IndexServiceImpl() --&gt; &lt;bean id=&quot;myDao1&quot; class=&quot;dao.BookCardDaoImpl&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;c&quot; ref=&quot;myConnection1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myService1&quot; class=&quot;service.IndexServiceImpl&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;bcd&quot; ref=&quot;myDao1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myConnection1&quot; class=&quot;util.MyConnection_mysql&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myConnection2&quot; class=&quot;util.MyConnection_sqlserver&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 在这里我介绍一下这份配置文件的相关信息 1 头文件我们一般从官方模板中拷贝过来，需要注意一下版本号 2 bean标记就是我们需要给项目中的每一个实例配置一个bean(pojo除外)，当哪一层需要调用时，spring会帮我们注入。 3 bean标记中id属性为在本文件中起一标识作用用来区分其他bean,class属性的值便是当前bean引用了哪一个类 ,scope属性的值为prototype为非单例的意思 4 bean标记中的子标记property便是当前这个类中需要注入的属性，name属性值为我们java类中的属性名，ref属性值为当前类需要引用哪一个实现类。 本例中我们可以看到dao中引用了myConnection1也就是引用了mysql的连接,如此一来便可以轻松切换mySQL和sqlServer两个数据库，而并不需要改动我们的任何逻辑代码。 下面我给出一个数据层dao的样例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class BookCardDaoImpl implements BookCardDao &#123; //只做属性的申明,不写死具体的实现 private MyConnection c; //提供一个set方法spring会自动注入 public void setC(MyConnection c) &#123; this.c = c; &#125; @Override public List&lt;BookCard&gt; getAllCardInfo() &#123; // 第一步：获取数据库连接 Connection conn = c.getConnection(); // 第二步：查询数据库 // （操作JDBC，需要sql语句，需要执行sql语句对象，需要执行sql语句后结果集合） String sql = &quot;select * from BookCard&quot;;// 需要执行的sql语句 PreparedStatement stmt = null;// 执行sql语句对象 ResultSet rs = null;// 执行sql语句后的结果集 try &#123; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 第三步 // 拿到rs后，执行一个遍历以及封装 List&lt;BookCard&gt; myBookCardList = new ArrayList&lt;BookCard&gt;(); try &#123; while (rs.next()) &#123; // 风格：实体类是一个pojo对象，一般直接new就行 BookCard bc = new BookCard(); // 进行数据库封装 bc.setCid(rs.getInt(&quot;cid&quot;)); bc.setName(rs.getString(&quot;name&quot;)); bc.setSex(rs.getString(&quot;sex&quot;)); bc.setCardDate(rs.getDate(&quot;cardDate&quot;)); bc.setDeposit(rs.getBigDecimal(&quot;deposit&quot;)); myBookCardList.add(bc); &#125; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; //关闭资源 try &#123; rs.close(); stmt.close(); conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 第5步返回结果集List给客户端 return myBookCardList; &#125; spring的环境在这一步已经是搭建完成了,我再来介绍一下spring的注入。大家可以清晰的看到左边这幅图呢是传统的面向对象编程的写法，每一层都与另外一层紧密耦合，当一层出现问题，层层都需要变动，在软件工程中是大忌 如图中,层与层之间都已经分离出来了，这里具体实现是通过在每一层都定义一个接口，层与层之间调用的都是接口并不关心是哪一个实现类，真正的实现类是谁不在代码中出现而是交给spring让他给我们注入。]]></content>
      <categories>
        <category>SSH框架整合</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
