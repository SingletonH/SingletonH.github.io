<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>艾达的梦</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.singletonh.top/"/>
  <updated>2019-01-29T01:09:21.699Z</updated>
  <id>http://www.singletonh.top/</id>
  
  <author>
    <name>艾达</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序-Storage更新</title>
    <link href="http://www.singletonh.top/2019/01/29/201901/Storage/"/>
    <id>http://www.singletonh.top/2019/01/29/201901/Storage/</id>
    <published>2019-01-29T01:09:21.699Z</published>
    <updated>2019-01-29T01:09:21.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>1、近期项目开发中接触到微信小程序，其中有部分业务需要用到数据本地存储，而微信的官方文档中并没用提供直接更新<code>Storage</code>的<code>API</code>。<br>2、通过<code>wx.setStorage(Object object)</code>可以达到覆盖原有数据达到更新的目的，但是在只修改某个对象中某个属性的值中使用这个<code>API</code>总感觉有点蹩脚。<br>3、下面笔者简单封装了一个方法用来修改<code>Storage</code>，若是有人知道更好的方法或者我的写法有问题还望不吝赐教。</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>小程序首次登录时需要输入账号密码，首次登录成功后将账号与<code>token</code>保存本地。下次启动小程序验证<code>token</code>是否过期，未过期直接登录，若过期则重新获取<code>token</code>并修改之前保存本地<code>token</code></p><h3 id="常规写法"><a href="#常规写法" class="headerlink" title="常规写法"></a>常规写法</h3><p><img src="https://upload-images.jianshu.io/upload_images/6695792-bcde166fd274f0fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原有Storage"><br>1、根据<code>key</code>“loginSetting”取出所有登录信息<br>2、获取新的<code>token</code>构建新的“loginSetting”<br>3、调用<code>setStorage(Object object)</code>保存</p><h3 id="封装更新API"><a href="#封装更新API" class="headerlink" title="封装更新API"></a>封装更新API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 更新本地缓存数据</span><br><span class="line"> * key: 本地缓存中指定的 key</span><br><span class="line"> * newData: 需要更新的内容</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">const updateStorageInfo = param =&gt; &#123;</span><br><span class="line">    var key = param.key</span><br><span class="line">    var newData = param.newData</span><br><span class="line"></span><br><span class="line">    var tempData = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    wx.getStorage(&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        success(res) &#123;</span><br><span class="line"></span><br><span class="line">            var storage = res.data</span><br><span class="line">            for (var prop in storage) &#123;</span><br><span class="line"></span><br><span class="line">                for (var pr in newData) &#123;</span><br><span class="line">                    if (prop == pr) &#123;</span><br><span class="line">                        storage[prop] = newData[pr]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tempData = storage</span><br><span class="line">            wx.setStorage(&#123;</span><br><span class="line">                key: key,</span><br><span class="line">                data: tempData,</span><br><span class="line">                success(res) &#123;</span><br><span class="line">                    param.success(res)</span><br><span class="line">                &#125;,</span><br><span class="line">                fail(res) &#123;</span><br><span class="line">                    param.fail(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail(res) &#123;</span><br><span class="line">            param.fail(res)</span><br><span class="line">        &#125;,</span><br><span class="line">        complete(res) &#123;</span><br><span class="line">            param.complete(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用updateStorageInfo-API"><a href="#使用updateStorageInfo-API" class="headerlink" title="使用updateStorageInfo API"></a>使用updateStorageInfo API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    token: that.randomWord(false, 32)</span><br><span class="line">&#125;</span><br><span class="line">util.updateStorageInfo(&#123;</span><br><span class="line">    key: &quot;loginSetting&quot;,</span><br><span class="line">    newData: data,</span><br><span class="line">    success(res) &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail(res) &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    complete(res) &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h4><p>1、原有<code>loginSetting</code>对象中有<code>account</code>，<code>token</code>属性，如果只需更改<code>token</code>属性。则只需构建需要更改内容的<code>json</code>对象，与更改的<code>key</code>。需要更改哪些数据则构建相应<code>json</code>即可。<br>2、如果更改了一个不存在的<code>key</code>则会进入<code>fail callback</code></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>1、实现思路还是需要根据<code>key</code>将整个对象取出，构建新对象再保存一次。之前相当于你要修改一个对象中的一个值，需要提供这个对象的标识，然后根据这个标识在本地存储中找到这个对象，接着把你需要改变的值与前面找到的数据进行合并，再保存。<br>2、根据<code>key</code>去本地查找对象与就对象和新对象匹配的逻辑类似，这也正是我们可以偷懒的地方。</p><h4 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h4><p><a href="https://github.com/SingletonH/Storage.git" target="_blank" rel="noopener">源码地址：https://github.com/SingletonH/Storage.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;1、近期项目开发中接触到微信小程序，其中有部分业务需要用到数据本地存储，而微信的官方文档中并没用提供直接更新&lt;code&gt;Storage&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;。&lt;br&gt;2、通过&lt;code&gt;wx.setStorage(Object object)&lt;/code&gt;可以达到覆盖原有数据达到更新的目的，但是在只修改某个对象中某个属性的值中使用这个&lt;code&gt;API&lt;/code&gt;总感觉有点蹩脚。&lt;br&gt;3、下面笔者简单封装了一个方法用来修改&lt;code&gt;Storage&lt;/code&gt;，若是有人知道更好的方法或者我的写法有问题还望不吝赐教。&lt;/p&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://www.singletonh.top/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="数据存储" scheme="http://www.singletonh.top/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>仿App Store转场动画 Swift语言实现</title>
    <link href="http://www.singletonh.top/2019/01/09/201901/SwiftTransition/"/>
    <id>http://www.singletonh.top/2019/01/09/201901/SwiftTransition/</id>
    <published>2019-01-09T13:13:48.718Z</published>
    <updated>2019-01-09T13:19:26.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><blockquote><p><a href="https://www.jianshu.com/p/d802eb2e5a31" target="_blank" rel="noopener">https://www.jianshu.com/p/d802eb2e5a31</a><br>本文主体思路是参考该博主的OC版本实现的<br><a href="https://www.jianshu.com/p/8a99020d954f" target="_blank" rel="noopener">https://www.jianshu.com/p/8a99020d954f</a><br>本文章介绍了转场动画中相关的一些概念，我感觉还是挺通俗易懂的。</p></blockquote><a id="more"></a><h3 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h3><p><img src="https://upload-images.jianshu.io/upload_images/6695792-899f9bb7318751e1.gif?imageMogr2/auto-orient/strip" alt="效果图"></p><h3 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h3><p>1、某日，我看到App Store上首页花里胡哨的转场动画体验着实不错，便想着自己实现一番。<br>2、作为一个萌新看到这样的效果完全联想不到是用何等操作实现的，so，百度，于是找到一个OC版。<br>3、然后也知道此效果主要是通过重写系统的push、pop动画达到的。作为一个Swift偏好者，难免不想翻译一下。<br>4、既然是需要push、pop，那么第一步是需要navigationController，我是直接在StoryBoard中嵌入的。<br>5、接下来是首页TableView布局，cell触摸缩小放大。<br>6、点击cell Push到详情页，本文重点，先放到后面再详说。<br>7、详情页依旧是TableView布局。顶部大图为Header，底部为文本，动态计算高度即可。<br>8、详情页伴随着左滑手势将页面按一定比例缩小，当缩小一定程度时Pop回首页。<br>9、不难发现，在详情页左滑时还有一个模糊的背景正是首页的截图。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>除了不知道如何重写pop和push之外其余思路清晰之后，便可以开始绘制基本UI了<br><img src="https://upload-images.jianshu.io/upload_images/6695792-f666c487494066c5.gif?imageMogr2/auto-orient/strip" alt="系统push、pop效果"></p><h4 id="一、重写Push、实现Delegate"><a href="#一、重写Push、实现Delegate" class="headerlink" title="一、重写Push、实现Delegate"></a>一、重写Push、实现Delegate</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>:<span class="title">UINavigationControllerDelegate</span>,<span class="title">UIViewControllerAnimatedTransitioning</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>?&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再来仔细观察从首页点击cell之后push到详情页这之间发生了什么？不难发现，其实就是将cell放大，有一种弹出的效果，而系统的push默认效果是新页面从左边覆盖过来。</p><blockquote><p>其实呢，在转场的过程中系统会提供一个视图容器用来盛装进行跳转控制器的视图，如下图所示，当前的FirstViewControllerpresent到SecondViewController的时候，此时，FirstViewController的view变成fromView，这个视图会自动加入到transtition container view中，然后在跳转过程中我们需要做的就是将SecondViewController的视图（此时是toView）加入到这个容器中，然后为这个toView的展现增加动画。<br>以上内容摘录自此处<br>作者：劉光軍_Shine<br>链接：<a href="https://www.jianshu.com/p/8a99020d954f" target="_blank" rel="noopener">https://www.jianshu.com/p/8a99020d954f</a><br>來源：简书</p></blockquote><p>有了一定概念之后，我们来解读一下下面的逻辑<br>1、拿到toView:即将要展示的视图，fromView:当前页面已展示的view<br>2、拿到toView,fromView之后，即将要展示动画，先将fromView隐藏，操作toView的fram和alpha以达到弹出放大的效果<br>3、将需要展示动画的view设置相应位置之后添加到transitionContext中<br>4、展示动画toView.alpha 0~&gt;1 逐渐显示，frame 首页cell frame~&gt; 详情页header frame 逐渐放大<br>5、移除用于展示动画的view，显示详情页view，显示首页view<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cell:<span class="type">HomeTableViewCell</span> = tableView.cellForRow(at: selectIndexPath!) <span class="keyword">as</span>! <span class="type">HomeTableViewCell</span></span><br><span class="line">        <span class="keyword">let</span> toVC:<span class="type">UIViewController</span> = transitionContext.viewController(forKey: .to)!</span><br><span class="line">        <span class="keyword">let</span> toView:<span class="type">UIImageView</span> = toVC.value(forKeyPath:<span class="string">"headerImageView"</span>) <span class="keyword">as</span>! <span class="type">UIImageView</span></span><br><span class="line">        <span class="keyword">let</span> fromView = cell.bgView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> containerView = transitionContext.containerView</span><br><span class="line">        <span class="keyword">let</span> snapshotView = <span class="type">UIImageView</span>(image: cell.bgImageView!.image)</span><br><span class="line">        snapshotView.frame = containerView.convert((fromView?.frame)!, from: fromView?.superview)</span><br><span class="line"></span><br><span class="line">        fromView?.isHidden = <span class="literal">true</span></span><br><span class="line">        toVC.view.frame = transitionContext.finalFrame(<span class="keyword">for</span>: toVC)</span><br><span class="line">        toVC.view.alpha = <span class="number">0</span></span><br><span class="line">        toView.isHidden = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">15</span>, y: <span class="number">20</span>, width: kScreenWidth-<span class="number">30</span>, height: <span class="number">30</span>))</span><br><span class="line">        titleLabel.textColor = <span class="type">UIColor</span>.white</span><br><span class="line">        titleLabel.font = <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">25</span>)</span><br><span class="line">        titleLabel.text = cell.titleLabel?.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> contentLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">15</span>, y: (kScreenWidth-<span class="number">40</span>)*<span class="number">1.3</span>-<span class="number">30</span>, width: kScreenWidth-<span class="number">30</span>, height: <span class="number">15</span>))</span><br><span class="line">        contentLabel.textColor = <span class="type">UIColor</span>.white</span><br><span class="line">        contentLabel.text = cell.contentLabel?.text</span><br><span class="line">        contentLabel.font = <span class="type">UIFont</span>(name: <span class="string">"PingFangSC-Light"</span>, size: <span class="number">15</span>)</span><br><span class="line">        contentLabel.alpha = <span class="number">0.5</span></span><br><span class="line">        snapshotView.addSubview(titleLabel)</span><br><span class="line">        snapshotView.addSubview(contentLabel)</span><br><span class="line"></span><br><span class="line">        containerView.addSubview(toVC.view)</span><br><span class="line">        containerView.addSubview(snapshotView)</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="keyword">self</span>.transitionDuration(using: transitionContext), delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.6</span>, initialSpringVelocity: <span class="number">1.0</span>, options: .curveLinear, animations: &#123;</span><br><span class="line">                    containerView.layoutIfNeeded()</span><br><span class="line">                    toVC.view.alpha = <span class="number">1.0</span></span><br><span class="line">                    <span class="keyword">self</span>.view.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: kScreenWidth, height: kScreenHeight)</span><br><span class="line">                    snapshotView.frame = containerView.convert(toView.frame, from: toView.superview)</span><br><span class="line">                    titleLabel.frame = <span class="type">CGRect</span>(x: <span class="number">22</span>, y: <span class="number">30</span>, width: kScreenWidth - <span class="number">30</span>, height: <span class="number">30</span>)</span><br><span class="line">                    contentLabel.frame = <span class="type">CGRect</span>(x: <span class="number">22</span>, y: kScreenWidth*<span class="number">1.3</span>-<span class="number">30</span>, width: kScreenWidth*<span class="number">1.3</span>-<span class="number">44</span>, height: <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">                &#125;) &#123; (finished) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">                    toView.isHidden = <span class="literal">false</span></span><br><span class="line">                    fromView?.isHidden = <span class="literal">false</span></span><br><span class="line">                    snapshotView.removeFromSuperview()</span><br><span class="line">                    <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">                    transitionContext.completeTransition(<span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="二、将首页截图传递给详情页备用"><a href="#二、将首页截图传递给详情页备用" class="headerlink" title="二、将首页截图传递给详情页备用"></a>二、将首页截图传递给详情页备用</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 截屏</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imageFromView</span><span class="params">()</span></span> -&gt;<span class="type">UIImage</span>&#123;</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.view.frame.size)</span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        <span class="keyword">self</span>.view.layer.render(<span class="keyword">in</span>: context!)</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> image!</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="三、详情页添加左滑返回手势"><a href="#三、详情页添加左滑返回手势" class="headerlink" title="三、详情页添加左滑返回手势"></a>三、详情页添加左滑返回手势</h4><p>1、给详情页的tableView添加手势<br>2、滑动过程中，实时获取当前滑动位置到初始位置的距离，实时计算该距离占据屏幕比例，相应缩小tableView大小并添加适应的圆角<br>3、手势结束时，获取手势发生的开始位置，手势结束后获取结束位置，计算出总共滑动范围<br>4、依据滑动范围所占屏幕的比例从而决定是否pop回上一页。若比例达到返回上一页，重写pop动画与push类似。若比例未达到，恢复详情页tableView frame<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">handleGesture</span><span class="params">(<span class="number">_</span> sender:UIGestureRecognizer)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakSelf = <span class="keyword">self</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> sender.state &#123;</span><br><span class="line">        <span class="keyword">case</span> .began:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"手势开始---"</span>)</span><br><span class="line">            <span class="keyword">let</span> currentPoint = sender.location(<span class="keyword">in</span>: <span class="keyword">self</span>.detailTableView)</span><br><span class="line">            startPointX = currentPoint.x</span><br><span class="line">            startPointY = currentPoint.y</span><br><span class="line">            isHorizontal = (startPointX &gt; <span class="type">CGFloat</span>(<span class="number">30</span>)) ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .changed:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"拖动中----"</span>)</span><br><span class="line">            <span class="keyword">let</span> currentPoint = sender.location(<span class="keyword">in</span>: <span class="keyword">self</span>.detailTableView)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> isHorizontal &#123;</span><br><span class="line">                <span class="keyword">if</span> ((currentPoint.x-startPointX)&gt;(currentPoint.y-startPointY)) &#123;</span><br><span class="line">                    scale = (kScreenWidth-(currentPoint.x-startPointX))/kScreenWidth</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    scale = (kScreenHeight-(currentPoint.y-startPointY))/kScreenHeight</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = (kScreenHeight-(currentPoint.y-startPointY))/kScreenHeight</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (scale &gt; <span class="type">CGFloat</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">                scale = <span class="type">CGFloat</span>(<span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scale &lt;= <span class="type">CGFloat</span>(<span class="number">0.8</span>)) &#123;</span><br><span class="line">                scale = <span class="type">CGFloat</span>(<span class="number">0.8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.detailTableView!.contentOffset.y&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 缩放</span></span><br><span class="line">                <span class="keyword">self</span>.detailTableView!.transform = <span class="type">CGAffineTransform</span>(scaleX: scale, y: scale)</span><br><span class="line">                <span class="comment">// 圆角</span></span><br><span class="line">                <span class="keyword">self</span>.detailTableView!.layer.cornerRadius = <span class="number">15</span> * (<span class="number">1</span>-scale)*<span class="number">5</span>*<span class="number">1.08</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.detailTableView!.isScrollEnabled = (scale &lt; <span class="number">0.99</span>) ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .ended:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"手势结束--"</span>)</span><br><span class="line">            <span class="keyword">if</span>(scale == <span class="number">0.8</span>)&#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now()+<span class="number">0.5</span>) &#123;</span><br><span class="line">                    weakSelf?.navigationController?.popViewController(animated: <span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.detailTableView!.isScrollEnabled = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> scale &gt; <span class="type">CGFloat</span>(<span class="number">0.8</span>) &#123;</span><br><span class="line">                <span class="type">UIView</span>.animate(withDuration: <span class="number">0.2</span>) &#123;</span><br><span class="line">                    weakSelf?.detailTableView!.layer.cornerRadius = <span class="number">0</span></span><br><span class="line">                    weakSelf?.detailTableView!.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、如果实际开发中多处需要用到这种转场效果可以抽出一个工具类来。<br>2、其实App Store中pop回来还有一个效果就是返回到首页时下面的文字说明会像一个抽屉一样由下往上收回的效果，有时间再去研究一下。另外，App Store上的背景配色之类一些细节处理也是非常极致的，有兴趣的朋友可以继续深究。<br>3、如有不足之处，望各路大神斧正。<br>4、<a href="https://github.com/SingletonH/SwiftTransition.git" target="_blank" rel="noopener">源码地址：https://github.com/SingletonH/SwiftTransition.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考文档：&quot;&gt;&lt;a href=&quot;#参考文档：&quot; class=&quot;headerlink&quot; title=&quot;参考文档：&quot;&gt;&lt;/a&gt;参考文档：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d802eb2e5a31&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/d802eb2e5a31&lt;/a&gt;&lt;br&gt;本文主体思路是参考该博主的OC版本实现的&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/8a99020d954f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/8a99020d954f&lt;/a&gt;&lt;br&gt;本文章介绍了转场动画中相关的一些概念，我感觉还是挺通俗易懂的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.singletonh.top/categories/iOS/"/>
    
    
      <category term="转场动画" scheme="http://www.singletonh.top/tags/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Swift3.0中函数的使用</title>
    <link href="http://www.singletonh.top/2016/11/19/201611/swift/"/>
    <id>http://www.singletonh.top/2016/11/19/201611/swift/</id>
    <published>2016-11-19T02:45:24.000Z</published>
    <updated>2016-11-19T02:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前不久，Swift语言也更新到了3.0版本，对编程有一定基础的朋友一定不会对函数这个概念陌生。而Swift语言中的函数也是大同小异的，今天就跟着小编来学习一下Swift3中函数的不一样的用法。</p><a id="more"></a><h3 id="1-定义一个函数以及调用"><a href="#1-定义一个函数以及调用" class="headerlink" title="1)定义一个函数以及调用"></a>1)定义一个函数以及调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//一，定义一个无参无返回值函数</span><br><span class="line"> func fun1()&#123;</span><br><span class="line">     print(&quot;this is first function&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"> fun1()</span><br></pre></td></tr></table></figure><h3 id="2-定义一个有参有返回值的函数"><a href="#2-定义一个有参有返回值的函数" class="headerlink" title="2)定义一个有参有返回值的函数"></a>2)定义一个有参有返回值的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func fun2(a:Int) -&gt;Int&#123;</span><br><span class="line">     print(&quot;this is second function&quot;)</span><br><span class="line">     return a</span><br><span class="line"> &#125;</span><br><span class="line"> //函数的调用</span><br><span class="line"> fun2(a: 2)</span><br></pre></td></tr></table></figure><p><span style="color: red">解析：</span>函数的参数放在函数名后的括号中，多个参数用逗号隔开，返回值类型用连接符和一个右尖括号指明(-&gt;)</p><h3 id="3-调用函数必须指明参数名且参数顺序不能改变"><a href="#3-调用函数必须指明参数名且参数顺序不能改变" class="headerlink" title="3)调用函数必须指明参数名且参数顺序不能改变"></a>3)调用函数必须指明参数名且参数顺序不能改变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func add1(firstNum:Int,addWithNum:Int) -&gt;Int&#123;</span><br><span class="line">    return firstNum+addWithNum</span><br><span class="line">&#125;</span><br><span class="line">//错误案例一、add1(2,3)调用函数必须指明参数名</span><br><span class="line">//错误案例二、add1(addWithNum: 4 ,firstNum:</span><br><span class="line">add1(firstNum: 2, addWithNum: 4)</span><br></pre></td></tr></table></figure><h3 id="4-在使用下划线在调用函数时省略指定参数名时，调用时则必须省略参数名"><a href="#4-在使用下划线在调用函数时省略指定参数名时，调用时则必须省略参数名" class="headerlink" title="4)在使用下划线在调用函数时省略指定参数名时，调用时则必须省略参数名"></a>4)在使用下划线在调用函数时省略指定参数名时，调用时则必须省略参数名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func add2(_ firstNum:Int,_ addWithNum:Int) -&gt;Int&#123;</span><br><span class="line">    return firstNum+addWithNum</span><br><span class="line">&#125;</span><br><span class="line">//错误案例add2(2, addWithNum: 4)</span><br><span class="line">add2(4, 5)</span><br></pre></td></tr></table></figure><h3 id="5-定义函数时指定外部参数"><a href="#5-定义函数时指定外部参数" class="headerlink" title="5)定义函数时指定外部参数"></a>5)定义函数时指定外部参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func add3(a firstNum:Int,b addWithNum:Int) -&gt;Int&#123;</span><br><span class="line">    return firstNum + addWithNum</span><br><span class="line">&#125;</span><br><span class="line">add3(a: 4, b: 5)//调用时则指定外部参数名</span><br></pre></td></tr></table></figure><h3 id="6-声明外部参数时，不能在函数内使用外部参数进行运算，同时在调用时也不能使用内部参数赋值"><a href="#6-声明外部参数时，不能在函数内使用外部参数进行运算，同时在调用时也不能使用内部参数赋值" class="headerlink" title="6)声明外部参数时，不能在函数内使用外部参数进行运算，同时在调用时也不能使用内部参数赋值"></a>6)声明外部参数时，不能在函数内使用外部参数进行运算，同时在调用时也不能使用内部参数赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//错误案例</span><br><span class="line">//func add4(a firstNum:Int,b addWithNum:Int) -&gt;Int&#123;</span><br><span class="line">//    return a + b值</span><br><span class="line">//&#125;</span><br><span class="line">//add4(firstNum: 2, addWithNum: 4)</span><br></pre></td></tr></table></figure><h3 id="7-在使用外部参数的情况下，不能使用下划线省略参数"><a href="#7-在使用外部参数的情况下，不能使用下划线省略参数" class="headerlink" title="7)在使用外部参数的情况下，不能使用下划线省略参数"></a>7)在使用外部参数的情况下，不能使用下划线省略参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//错误案例</span><br><span class="line">//func add5(_ a firstNum:Int,b addWithNum:Int) -&gt;Int&#123;</span><br><span class="line">//    return firstNum + addWithNum</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><h3 id="8-在定义一个带参的函数时可以给参数设置一个默认值"><a href="#8-在定义一个带参的函数时可以给参数设置一个默认值" class="headerlink" title="8)在定义一个带参的函数时可以给参数设置一个默认值"></a>8)在定义一个带参的函数时可以给参数设置一个默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func add5(firstNum:Int,addWithNum:Int = 2) -&gt;Int&#123;</span><br><span class="line">    return firstNum+addWithNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add5(firstNum:4) //得到结果6</span><br><span class="line">add5(firstNum: 4,addWithNum: 6)//得到结果10</span><br></pre></td></tr></table></figure><h3 id="9-函数在Swift语言中是第一等类型（类似于Java中的类），意味着可以是函数的参数以及返回值"><a href="#9-函数在Swift语言中是第一等类型（类似于Java中的类），意味着可以是函数的参数以及返回值" class="headerlink" title="9)函数在Swift语言中是第一等类型（类似于Java中的类），意味着可以是函数的参数以及返回值"></a>9)函数在Swift语言中是第一等类型（类似于Java中的类），意味着可以是函数的参数以及返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 func outer4(f:()-&gt;Void) -&gt; (Int,Int)-&gt;(Int,Int) &#123;</span><br><span class="line">2     </span><br><span class="line">3     //......</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure><p><span style="color: green">备注：</span>Swift教程持续更新中，欢迎各位学习交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前不久，Swift语言也更新到了3.0版本，对编程有一定基础的朋友一定不会对函数这个概念陌生。而Swift语言中的函数也是大同小异的，今天就跟着小编来学习一下Swift3中函数的不一样的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.singletonh.top/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://www.singletonh.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate一对多配置</title>
    <link href="http://www.singletonh.top/2016/11/10/201611/onetomany/"/>
    <id>http://www.singletonh.top/2016/11/10/201611/onetomany/</id>
    <published>2016-11-10T12:28:02.000Z</published>
    <updated>2016-11-10T12:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>在java的世界中万事万物皆对象，而在一个工程中往往是涉及到多个对象。那么在处理多个对象之间的关系显得尤为重要，对象关系大致可以分为四种。一对一、一对多、多对一、多对多，而一对一无需多讲，一对多与多对一则是考虑的角度问题，其本质都是一样的，最后多对多也是可以拆分为一对多的关系。本例讲解一个订单与订单明细的例子便属于一个典型的一对多关系。</p><a id="more"></a><p><span style="color: brown">需求：</span>本例需要做一个饭馆管理客户小型的点餐系统，主要是管理客户订单。<br><span style="color: red">误区：</span>对于面向对象编程语言的初学者来说建模时可能会定义一个订单对象包含订单编号，订单日期，订单人数，所定菜名，份数，价格等属性的一个对象。<br><span style="color: green">正解：</span>此处应分为两个对象，一个订单对象（订单号，人数，日期，等）一个订单明细对象（所定菜名，份数，价格等）。因为一个对象与属性的关系应该是十分紧密的，比如说菜的价格是与菜关联的并没有与订单存在直接关系。一个客户（订单对象）可能会点多个菜（订单明细对象），这便是我们问题的引入点。</p><h3 id="一对多配置方式一、使用jpa注解"><a href="#一对多配置方式一、使用jpa注解" class="headerlink" title="一对多配置方式一、使用jpa注解"></a>一对多配置方式一、使用jpa注解</h3><p>首先看一下我们one端，也就是订单对象端部分代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import javax.persistence.CascadeType;</span><br><span class="line">import javax.persistence.Column;</span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.FetchType;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line">import javax.persistence.OneToMany;</span><br><span class="line">import javax.persistence.Table;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;t_order&quot;)</span><br><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">    private Integer id;// 主键</span><br><span class="line">    @Column(name=&quot;p_Count&quot;,nullable=false)</span><br><span class="line">    private Integer pCount;// 人数</span><br><span class="line">    @Column(name=&quot;pub_Date&quot;,nullable=false)</span><br><span class="line">    private Date pubDate;//日期</span><br><span class="line">    </span><br><span class="line">    private Set&lt;OrderItem&gt; orderItems = new HashSet&lt;OrderItem&gt;();</span><br><span class="line">    </span><br><span class="line">    @OneToMany(mappedBy=&quot;order&quot;,cascade=&#123;CascadeType.ALL&#125;,fetch=FetchType.EAGER)</span><br><span class="line">    public Set&lt;OrderItem&gt; getOrderItems() &#123;</span><br><span class="line">        return orderItems;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接下是我们的 many端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;t_order_item&quot;)</span><br><span class="line">public class OrderItem &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">    private Integer id;//主键</span><br><span class="line">    @Column(name=&quot;detail_desc&quot;,nullable=false,length=50)</span><br><span class="line">    private String detailDesc;//菜名</span><br><span class="line">    @Column(name=&quot;price&quot;,nullable=false)</span><br><span class="line">    private Integer price;//单价</span><br><span class="line">    @Column(name=&quot;c_count&quot;,nullable=false)</span><br><span class="line">    private Integer cCount;//数量</span><br><span class="line">    </span><br><span class="line">    private Order order;</span><br><span class="line">    </span><br><span class="line">    @ManyToOne(cascade=&#123;CascadeType.REMOVE&#125;,optional=true,fetch=FetchType.EAGER)</span><br><span class="line">    @JoinColumn(name=&quot;orderid&quot;)</span><br></pre></td></tr></table></figure></p><p><span style="color: grenn">解析：</span>hibernate主要通过onetomany和manytoone这两个注解建立起订单表与订单明细表的主外键引用关系。主表对象通过定义set集合存放从表对象，从表定义一个属性为主表对象，从而使两个对象关联起来。</p><h3 id="一对多配置方式二、使用xml配置"><a href="#一对多配置方式二、使用xml配置" class="headerlink" title="一对多配置方式二、使用xml配置"></a>一对多配置方式二、使用xml配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC </span><br><span class="line">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; </span><br><span class="line">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hibernate-mapping package=&quot;order&quot;&gt;</span><br><span class="line">    &lt;class name=&quot;order.entity.Order&quot; table=&quot;t_order&quot;&gt;</span><br><span class="line">        &lt;id name=&quot;id&quot; type=&quot;long&quot; column=&quot;ID&quot;&gt;</span><br><span class="line">            &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;</span><br><span class="line">        &lt;/id&gt;</span><br><span class="line">        &lt;property name=&quot;pCount&quot; type=&quot;string&quot;&gt;</span><br><span class="line">            &lt;column name=&quot;p_Count&quot; length=&quot;15&quot;&gt;&lt;/column&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;set name=&quot;orders&quot; cascade=&quot;save-update&quot; lazy=&quot;false&quot;&gt;</span><br><span class="line">            &lt;key column=&quot;orderItem_ID&quot;&gt;&lt;/key&gt;</span><br><span class="line">            &lt;one-to-many class=&quot;order.entity.OrderItem&quot;/&gt;</span><br><span class="line">        &lt;/set&gt;      </span><br><span class="line">    &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;hibernate-mapping package=&quot;order&quot;&gt;</span><br><span class="line">    &lt;class name=&quot;order.entity.OrderItem&quot; table=&quot;t_orderItem&quot;&gt;</span><br><span class="line">        &lt;id name=&quot;id&quot; type=&quot;long&quot; column=&quot;orderItem_ID&quot;&gt;</span><br><span class="line">            &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt;</span><br><span class="line">        &lt;/id&gt;</span><br><span class="line">         ...</span><br><span class="line">        &lt;many-to-one name=&quot;customer&quot; column=&quot;CUSTOMER_ID&quot; class=&quot;order.entity.Order&quot;/&gt;</span><br><span class="line">    &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>java程序中的对象，数据库中的表，这两者在设计中往往存在不同步状况，建好一个项目中的模显得尤为重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;在java的世界中万事万物皆对象，而在一个工程中往往是涉及到多个对象。那么在处理多个对象之间的关系显得尤为重要，对象关系大致可以分为四种。一对一、一对多、多对一、多对多，而一对一无需多讲，一对多与多对一则是考虑的角度问题，其本质都是一样的，最后多对多也是可以拆分为一对多的关系。本例讲解一个订单与订单明细的例子便属于一个典型的一对多关系。&lt;/p&gt;
    
    </summary>
    
      <category term="hibernate" scheme="http://www.singletonh.top/categories/hibernate/"/>
    
    
      <category term="hibernate" scheme="http://www.singletonh.top/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>hibernate UUID问题</title>
    <link href="http://www.singletonh.top/2016/11/03/201611/uuid/"/>
    <id>http://www.singletonh.top/2016/11/03/201611/uuid/</id>
    <published>2016-11-03T12:34:46.000Z</published>
    <updated>2016-11-03T12:34:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>hibernate对于字符串类型主键支持UUID主键生成策略，(号称是世界上唯一的字符串)<br>运行环境：运行环境：hibernate5.2，mysql5.6。</p><a id="more"></a><h3 id="一，使用hibernate给String类型id设置uuid的两种方式"><a href="#一，使用hibernate给String类型id设置uuid的两种方式" class="headerlink" title="一，使用hibernate给String类型id设置uuid的两种方式"></a>一，使用hibernate给String类型id设置uuid的两种方式</h3><p>①，注解</p><p>@GeneratedValue(generator = “uuid”)</p><p>@GeneratedValue(generator = “uuid”) @GenericGenerator(name = “uuid”, strategy = “uuid”)</p><p>②，配置文件</p><generator class="uuid.hex"> <p>备注：通过这两种方式都可以给String类型id设置uuid，由hibernate自动生成一个id值插入数据库。如果在数据库直接插入数据则必须传入主键id，未经过hibernate是不会生成id的。</p><h3 id="二，根据uuid操作对象时应注意的问题"><a href="#二，根据uuid操作对象时应注意的问题" class="headerlink" title="二，根据uuid操作对象时应注意的问题"></a>二，根据uuid操作对象时应注意的问题</h3><p>由于主键id为字符串类型，在做数据库操作(增删改查)时id必须用单引号引用，否则失败。</p><p>id值没有使用单引号引用，并且我们在没有使用hibernate给我们自动生成uuid时，自己手动<span style="color: red">插入较短</span>的id时，mysql具有一定的兼容性，操作正常。</p></generator>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;hibernate对于字符串类型主键支持UUID主键生成策略，(号称是世界上唯一的字符串)&lt;br&gt;运行环境：运行环境：hibernate5.2，mysql5.6。&lt;/p&gt;
    
    </summary>
    
      <category term="易错笔记" scheme="http://www.singletonh.top/categories/%E6%98%93%E9%94%99%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="易错笔记" scheme="http://www.singletonh.top/tags/%E6%98%93%E9%94%99%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈系统架构&lt;一&gt;</title>
    <link href="http://www.singletonh.top/2016/10/31/201610/framework/"/>
    <id>http://www.singletonh.top/2016/10/31/201610/framework/</id>
    <published>2016-10-31T07:55:56.000Z</published>
    <updated>2016-10-31T07:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>博主刚刚从事于Web后端开发与学习不久，开发项目经验也是有限的。不过今天依旧将一些个人的想法记录下来，我的构想或许不太正确，还望各位大牛能给我多多建议。</p><a id="more"></a><h3 id="我们从编程开始讲起"><a href="#我们从编程开始讲起" class="headerlink" title="我们从编程开始讲起"></a>我们从编程开始讲起</h3><p>　　博主是偏向于后端开发的程序员，从入门到如今，学过的语言，技术为数不多。但我敢肯定的是：无论是哪一门语言，其语法只要是一个有正常逻辑思维能力的人再加上他一定时间的研究学习。弄懂这门语言的语法是没有任何问题的。那么问题来了。在学过那么多编程语言后，又有多少人能够深刻理解编程过程中涉及到的编程思想。也就造成一部分人在学习过程中知道一个需求该怎么写，但从来没有思考过为什么需要这样写。因此，我在学习一门语言中，常是会问自己，这样写的好处是什么，坏处又有什么，益处也是颇多。</p><h3 id="Next-谈谈需求分析"><a href="#Next-谈谈需求分析" class="headerlink" title="Next: 谈谈需求分析"></a>Next: 谈谈需求分析</h3><p>　　需求分析对于一个项目来说应该是重中之重，这直接影响到一个项目的成败。而需求分析之前往往还需要通过大量准确的市场调研，毕竟我们最终开发的东西是需要为人民服务，给我们带来便利的。在通过一帮子人不停的讨论、分析，最终将需求报告总结出来之后，又有一个重要的部分需要完成。那便是是项目建模以及权限分配等等，这些模型作为一个项目的分子级别的存在同样是不能容忍存在任何差异的。</p><h3 id="Then-异常处理"><a href="#Then-异常处理" class="headerlink" title="Then: 异常处理"></a>Then: 异常处理</h3><p>　　无论一个多大多小的项目一定会存在或多或少的bug，如果不存在反而这个项目是存在问题的。在我们代码的编写过程中应当考虑任何有可能发生异常的情况，并给出相应的处理方案。例如，服务器突然发生异常，用户的不正当操作，亦或是用户的并发操作等都有可能给我们的项目带来各种各样的问题。引用伟人说过的一句话——我们不能规避误差，但可以规避错误。方向上的东西一定不允许出错，细节上的尽量规避。而对于比较重要的连环操作更是应当引入事务的支持，例如银行转账，A给B转账1000，先从A账户的余额判断是否大于1000，再减去1000，之后再在B账户的余额增加1000.（实际过程肯定更加严谨）如果在A账户转出成功后，B账户转入失败了呢。这一系列操作应当要回滚。顾对于一个项目重要的部分应添加事务的支持，要么这一些连环操作都执行成功，要么执行失败，回退到执行之前的状态。</p><h3 id="Latter-框架的使用"><a href="#Latter-框架的使用" class="headerlink" title="Latter: 框架的使用"></a>Latter: 框架的使用</h3><p>　　在一个项目中或多或少需要引用各种各样的框架使我们的项目更加强健，稳固。同时，我们也不能过分依赖于框架，使我们的项目过分的与框架耦合在一起。假如，我们发现在我们项目中某套框架存在很大的漏洞，又或者是有一套全新的更加完善的框架出现，需要替换框架时，此时我们才发现我们的代码与框架已经紧密耦合在一起了。这个时候如需要替换的话，对我们的成本来说无疑是巨大的打击。例如，在web后端中常用的一套框架spring，如果我们在代码中总是使用spring的注解，而抛弃xml文件可能就会造成这样的问题。</p><h3 id="Last-前后端分离"><a href="#Last-前后端分离" class="headerlink" title="Last:前后端分离"></a>Last:前后端分离</h3><p>随着互联网的高速发展，以及移动设备的普及，我们的项目更是要适应多平台的使用。在我们的后端代码中更是不能与我们前端页面出现紧密耦合，此时不防使用SOA(面向服务体系架构)思想。这里我分享一位大牛(@夏天的森林)对于前后端分离的博客__<a href="http://www.cnblogs.com/sharpxiajun/p/3531665.html" target="_blank" rel="noopener">Web应用架构的新趋势</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>这是属于本人从一个专业角度并不是非常成熟的角度分析的成果，有何不对的地方，望各位指正。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;博主刚刚从事于Web后端开发与学习不久，开发项目经验也是有限的。不过今天依旧将一些个人的想法记录下来，我的构想或许不太正确，还望各位大牛能给我多多建议。&lt;/p&gt;
    
    </summary>
    
      <category term="系统架构" scheme="http://www.singletonh.top/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="系统架构" scheme="http://www.singletonh.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>利用反射手写代码实现spring AOP</title>
    <link href="http://www.singletonh.top/2016/10/31/201610/spring_aop_m/"/>
    <id>http://www.singletonh.top/2016/10/31/201610/spring_aop_m/</id>
    <published>2016-10-31T07:42:14.000Z</published>
    <updated>2016-10-31T07:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇博客我们继续深入spring，还是在原有的基础上进行改造。下面请先欣赏一下博主画的一张aop简图（没有艺术天分，画的不好莫见怪）</p><a id="more"></a><p><img src="\images\blog_img\911236-20161020143129842-2040551087.png" alt=""><br><span style="color: blue">解析：</span>往往在我们的系统的多个核心流程中会有一部分与之关系不大的相同的横切流程，例如权限认证，事务管理。因此我们一般会抽象出这些相同的比较次要的交给spring aop的Handler来统一处理这些横切流程也就是上图中绿色部分。接下来我们看一下本例结构图：<br><img src="\images\blog_img\911236-20161020191254029-456292249.png" alt=""><br><span style="color: blue">解析：</span>1，我们的Hostess对象是Master接口的实现，主要实现了WalkDog()和shopping()两个方法，而WalkDog()方法则是调用的是Dog接口的实现类的bark()方法。<br>2，我们整个程序的入口Client调用的Hostess对象的两个核心方法，HumanHandler处理的Hostess对象的横切流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); </span><br><span class="line">        </span><br><span class="line">        Master master = (Master)context.getBean(&quot;humanProxy&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        </span><br><span class="line">        master.shopping();</span><br><span class="line">        master.WalkDog();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package human;</span><br><span class="line"></span><br><span class="line">import dog.Dog;</span><br><span class="line"></span><br><span class="line">public class Hostess implements Master &#123;</span><br><span class="line">    </span><br><span class="line">    private Dog dog;</span><br><span class="line">    </span><br><span class="line">    public void setDog(Dog dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void WalkDog() &#123;</span><br><span class="line"></span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void shopping()&#123;</span><br><span class="line">        System.out.println(&quot;疯狂购物中&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>通过以上代码我们不难发现我们的程序只是调用核心业务，而往往核心业务的周围有很多繁琐的相对于比较次要的横切业务。利用本例中遛狗，购物之前，我们需要再家做一些前提准备。例如：整理一下着装，锁上房门等等，回家之后有需要换鞋之类的。因此我们还需要一个handler来处理这些业务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package aop;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class HumanHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;// 目标是不固定</span><br><span class="line">    </span><br><span class="line">    public void setTarget(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * return 返回是原来目标方法所返回的内容 method 就是要执行的方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        before();</span><br><span class="line">        // 具体的业务逻辑代码</span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        after();</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before() &#123;</span><br><span class="line">        // 前置任务</span><br><span class="line">        System.out.println(&quot;[代理执行前置任务]整理着装&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行前置任务]带上钥匙&quot;);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;[核心业务开始]*****************&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void after() &#123;</span><br><span class="line">        // 后置任务</span><br><span class="line">        System.out.println(&quot;[核心业务结束]*****************&quot;);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行后置任务]开门&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行后置任务]换鞋&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span style="color: blue">解析：</span>有了handler我们还需要一个代理工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.aop.framework;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProxyFactoryBean &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line">    </span><br><span class="line">    private InvocationHandler handler;</span><br><span class="line">    </span><br><span class="line">    public ProxyFactoryBean(Object target,InvocationHandler handler)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回本类的一个实例</span><br><span class="line">    public Object getProxyBean() throws IllegalArgumentException, InstantiationException, IllegalAccessException, ClassNotFoundException&#123;</span><br><span class="line">        Object obj = Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                handler);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><span style="color: blue">解析：</span>接下来我们来看一下本例的具体配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;hostess&quot; class=&quot;human.Hostess&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dog&quot; ref=&quot;dog1&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;dog1&quot; class=&quot;dog.Taidi&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;dog2&quot; class=&quot;dog.Labuladuo&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;humanHandler&quot; class=&quot;aop.HumanHandler&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;hostess&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;humanProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;handlerName&quot; ref=&quot;humanHandler&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;hostess&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>最后一步也是关键，本类中使用到的实例需要我们通过读取上面这份配置文件然后通过反射构造出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package aop;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line">import org.springframework.aop.framework.ProxyFactoryBean;</span><br><span class="line"></span><br><span class="line">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    private String fileName;</span><br><span class="line">    </span><br><span class="line">    public ClassPathXmlApplicationContext(String fileName)&#123;</span><br><span class="line">        this.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object getBean(String beanid) &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;传递过来的ID:&quot;+beanid);</span><br><span class="line">        </span><br><span class="line">        //获取本类的当前目录</span><br><span class="line">        String currentPath = this.getClass().getResource(&quot;&quot;).getPath().toString();</span><br><span class="line">        SAXReader reader = new SAXReader();//DOM4J解释器</span><br><span class="line">        Document doc = null;//xml文档本身</span><br><span class="line">        Object obj = null;//目标表创建出来的实例</span><br><span class="line">        try &#123;</span><br><span class="line">            doc = reader.read(  new File(currentPath+fileName)  );</span><br><span class="line">            String xpath = &quot;/beans/bean[@id=&apos;&quot;+beanid+&quot;&apos;]&quot;;</span><br><span class="line">            Element beanNode = (Element) doc.selectSingleNode(xpath);</span><br><span class="line">            String className = beanNode.attributeValue(&quot;class&quot;);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            if (&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;.equals(className))&#123;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                Element interceptorNamesNode =</span><br><span class="line">                        (Element) beanNode.selectSingleNode(&quot;property[@name=&apos;handlerName&apos;]&quot;);</span><br><span class="line">                </span><br><span class="line">                String handlerName_value = interceptorNamesNode.attributeValue(&quot;ref&quot;);</span><br><span class="line"></span><br><span class="line">                Element targetNode = (Element) beanNode.selectSingleNode(&quot;property[@name=&apos;target&apos;]&quot;);</span><br><span class="line">                String targetName_value = targetNode.attributeValue(&quot;ref&quot;);</span><br><span class="line">                </span><br><span class="line">                return forProxyFactoryBean(targetName_value,handlerName_value);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            obj = Class.forName(className).newInstance();</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            //查找下一代</span><br><span class="line">            Element propertyNode = (Element) beanNode.selectSingleNode(&quot;property&quot;);</span><br><span class="line">            if (propertyNode!=null)&#123;</span><br><span class="line">                //注入</span><br><span class="line">                //System.out.println(&quot;发现property节点，准备注入&quot;);</span><br><span class="line">                //需要注入的属性名</span><br><span class="line">                String propertyName = propertyNode.attributeValue(&quot;name&quot;);</span><br><span class="line">                //System.out.println(&quot;需要注入的属性：&quot;+propertyName);</span><br><span class="line">                </span><br><span class="line">                //注入方法</span><br><span class="line">                String executeMethod = &quot;set&quot;+(propertyName.substring(0, 1)).toUpperCase()+propertyName.substring(1,propertyName.length());</span><br><span class="line">                //System.out.println(&quot;需要执行注入方法：&quot;+executeMethod);</span><br><span class="line">                </span><br><span class="line">                //需要注入的对象实例</span><br><span class="line">                String di_object_name = propertyNode.attributeValue(&quot;ref&quot;);</span><br><span class="line">                //System.out.println(&quot;注入的对象是：&quot;+di_object_name);</span><br><span class="line">                </span><br><span class="line">                //定义我们的需要注入的对象实例[递归算法：1.层级是不知道多少层的  2.自己调用自己  3.最后1层会自己结束]</span><br><span class="line">                Object di_object = getBean(di_object_name);</span><br><span class="line">                //System.out.println(&quot;xxx:&quot;+di_object);</span><br><span class="line">                </span><br><span class="line">                //Method method = obj.getClass().getMethod(executeMethod,di_object.getClass().getInterfaces());// new Method(executeMethod);</span><br><span class="line">                Method []methods = obj.getClass().getMethods();</span><br><span class="line">                </span><br><span class="line">                for (Method m : methods) &#123;</span><br><span class="line">                    if(executeMethod.equals(m.getName())  ) &#123;</span><br><span class="line">                        m.invoke(obj, di_object);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                System.out.println(&quot;没有属性，结束即可&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;返回实例：&quot;+obj);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Object forProxyFactoryBean(String targetName_value,String handlerName_value) throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;目标对象&quot;+targetName_value);</span><br><span class="line">        </span><br><span class="line">        Object target = getBean(targetName_value);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;代理对象&quot;+handlerName_value);</span><br><span class="line">        </span><br><span class="line">        InvocationHandler handler = (InvocationHandler) getBean(handlerName_value);</span><br><span class="line">        </span><br><span class="line">        return new ProxyFactoryBean(target,handler).getProxyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下:<br><img src="\images\blog_img\911236-20161020194022201-1340814490.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1 spring aop将我们的系统分为两部分，一核心业务，二横切业务。我们的只需关注核心业务，横切业务统一交给代理去处理。<br>2 本例依旧是利用反射调用横切方法实现aop，还是那句话，我们自己写的自然是漏洞百出，只是为了说明问题。作为一个开源的框架，如果对spring源码感兴趣的朋友可以自行查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇博客我们继续深入spring，还是在原有的基础上进行改造。下面请先欣赏一下博主画的一张aop简图（没有艺术天分，画的不好莫见怪）&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.singletonh.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.singletonh.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>自己动手编写spring IOC源码</title>
    <link href="http://www.singletonh.top/2016/10/31/201610/spring_ioc_m/"/>
    <id>http://www.singletonh.top/2016/10/31/201610/spring_ioc_m/</id>
    <published>2016-10-31T07:04:48.000Z</published>
    <updated>2016-10-31T07:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.singletonh.top/2016/10/30/201610/spring_ioc_m/"><img src="\images\blog_img\tuijian.jpeg"></a><br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于spring IOC概念不是很了解的朋友可以阅读我上一篇博客__<a href="http://www.singletonh.top/2016/10/28/201610/spring_ioc/">轻松理解spring IOC</a> 通过这篇博客的理解之后，相信大家会对spring的IOC概念会有进一步的理解。接下来我先预览一下本例中java的类图关系。<br><img src="\images\blog_img\911236-20161017154746092-716529139.png" alt=""><br><span style="color: blue">解析：</span>我们有一个Master接口，接口中定义了一个WalkDog()遛狗的方法，Hostess是对这个接口的具体实现。然后我们有一个Dog接口，接口中有一个bark()方法，Labuladuo和Taidi是对其的实现。最后我们的程序入口Client类调用Hostess对象的WalkDog方法。<br><span style="color: green">需求：</span>Hostess对象遛狗需要一个狗对象，目前我们的类中有两个符合需求的对象，我们只要在配置文件中进行相关配置便可以指定我们的Hostess对象调用的是哪一个具体的Dog对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        Master master = (Master)context.getBean(&quot;hostess&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;***********************************&quot;);</span><br><span class="line">        master.WalkDog();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><span style="color: blue">解析：</span>从main方法的前两句原spring的代码中我们可以猜想，spring框架中一定是定义了ApplicationContext这个接口，并且接口中定义了一个getBean()的方法，而ClassPathXmlApplicationContext类肯定是对其的实现。既然是我们自己动手写spring框架，我们把这个接口和类实现了也就可以了。</p><p>接口 ApplicationContext </p><pre><code>public interface ApplicationContext {    public Object getBean(String beanid);}</code></pre><p>实现类 ClassPathXmlApplicationContext  </p><pre><code>package com;import java.io.File;import java.lang.reflect.Method;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class ClassPathXmlApplicationContext implements ApplicationContext {    private String fileName;    public ClassPathXmlApplicationContext(String fileName){        this.fileName = fileName;    }    @Override    public Object getBean(String beanid) {        //获取本类的当前目录        String currentPath = this.getClass().getResource(&quot;&quot;).getPath().toString();        SAXReader reader = new SAXReader();//DOM4J解释器        Document doc = null;//xml文档本身        Object obj = null;//目标表创建出来的实例        try {            doc = reader.read(  new File(currentPath+fileName)  );            String xpath = &quot;/beans/bean[@id=&apos;&quot;+beanid+&quot;&apos;]&quot;;            Element beanNode = (Element) doc.selectSingleNode(xpath);            String className = beanNode.attributeValue(&quot;class&quot;);            obj = Class.forName(className).newInstance();            Element propertyNode = (Element) beanNode.selectSingleNode(&quot;property&quot;);            if(propertyNode!=null){                System.out.println(&quot;当前bean有属性需要注入&quot;);                String propertyName = propertyNode.attributeValue(&quot;name&quot;);                System.out.println(&quot;当前bean需要注入的属性为&quot;+propertyName);                //拼接出注入方法                String setMethod = &quot;set&quot;+(propertyName.substring(0, 1)).toUpperCase()+propertyName.substring(1,propertyName.length());                System.out.println(&quot;自动调用注入方法&quot;+setMethod);                String set_object_name = propertyNode.attributeValue(&quot;ref&quot;);                System.out.println(&quot;需要注入的对象名&quot;+set_object_name);                Object di_object = getBean(set_object_name);                System.out.println(&quot;注入的对象实例&quot;+di_object);                Method []methods = obj.getClass().getMethods();                for (Method m : methods) {                    if(setMethod.equals(m.getName())  ) {                        m.invoke(obj, di_object);                        break;                    }                }            }else{                System.out.println(&quot;当前bean没有属性，无需注入直接结束&quot;);            }        } catch (Exception e) {            e.printStackTrace();        }        return obj;    }}</code></pre><p>配置文件 applicationContext.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt;    &lt;bean id=&quot;hostess&quot; class=&quot;com.Hostess&quot;&gt;        &lt;property name=&quot;dog&quot; ref=&quot;Taidi_dog&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;Taidi_dog&quot; class=&quot;com.Taidi&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;Labuladuo_dog&quot; class=&quot;com.Labuladuo&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p><span style="color: blue">解析：</span>① 我们的applicationContext.xml文件主要是配置我们的java bean。这里我们自己写一份这样的文件通知我们自己的框架有哪些对象需要注入。<br>② 接口 ApplicationContext 这里我只是定义了一个方法就不多解释了。<br>③ 实现类 ClassPathXmlApplicationContext 主要是解析我们的xml文件然后构造实例的一个类。解析xml文件我们主要使用的是dom4j，获取各个节点和节点属性与属性值。创建对象则是通过反射的方式构造对象 [obj = Class.forName(className).newInstance();]。 在判断一个对象是否有属性需要注入则是使用递归算法对其一一注入。</p><p>最后： 我们来看一下运行结果<br><img src="\images\blog_img\911236-20161017163317513-410665567.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们自己手写的框架自然没有spring框架严谨，安全(不然它早倒闭了)，不过spring的原理我们自己的也是大同小异的。通过源码级别的解读，相信大家已经可以熟练掌握IOC原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.singletonh.top/2016/10/30/201610/spring_ioc_m/&quot;&gt;&lt;img src=&quot;\images\blog_img\tuijian.jpeg&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.singletonh.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.singletonh.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>eclipse中SSH三大框架环境搭建&lt;一&gt;</title>
    <link href="http://www.singletonh.top/2016/10/31/201610/ssh01/"/>
    <id>http://www.singletonh.top/2016/10/31/201610/ssh01/</id>
    <published>2016-10-31T06:24:28.000Z</published>
    <updated>2016-10-31T06:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.singletonh.top/2016/10/26/201610/ssh01/"><img src="\images\blog_img\struts2.png"></a><br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里先简单介绍一下我使用的三大框架版本以及下载地址<br><a href="http://struts.apache.org/download.cgi#struts252" target="_blank" rel="noopener">struts-2.3.30下载</a><br><a href="http://repo.spring.io/release/org/springframework/spring" target="_blank" rel="noopener">spring-framework-4.3.1下载</a><br><a href="http://hibernate.org/orm/downloads" target="_blank" rel="noopener">hibernate-release-5.2.2下载</a>  </p><h3 id="第一步：创建工程"><a href="#第一步：创建工程" class="headerlink" title="第一步：创建工程"></a>第一步：创建工程</h3><p>将上面的jar包下载解压完成后，先在eclipse中新建一个web工程，新建工程的同时最好选上创建的同时添加web.xml文件<br><img src="http://images2015.cnblogs.com/blog/911236/201609/911236-20160906151937019-1449597708.png" alt="创建工程" title="创建web.xml文件">  </p><h3 id="第二步：导入jar包"><a href="#第二步：导入jar包" class="headerlink" title="第二步：导入jar包"></a>第二步：导入jar包</h3><p>找到下载并解压好的strtus文件中找到apps目录下的strtus2-blank.war的压缩包，再找到这个压缩包中WEB-INF目录下的lib目录，最后将lib中的所有jar包复制到我们新建项目的lib包中<br><img src="http://images2015.cnblogs.com/blog/911236/201609/911236-20160906152512566-1824238943.png" alt="strtus压缩包" title="strtus压缩包">  </p><h3 id="第三步：配置web-xml文件"><a href="#第三步：配置web-xml文件" class="headerlink" title="第三步：配置web.xml文件"></a>第三步：配置web.xml文件</h3><p>找到前面lib包所在的同级目录下的web.xml文件，复制出其配置的过滤器，如下：<br>注意：由于struts版本不同所以其配置的过滤器写法上略有差异，我们一般参照官方给的模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;</span><br><span class="line">        org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</span><br><span class="line">        &lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;struts2&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><h3 id="第四步：编写源码"><a href="#第四步：编写源码" class="headerlink" title="第四步：编写源码"></a>第四步：编写源码</h3><p>我们可以写我们的action类了，编写action类我们一般会继承ActionSupport父类在aciton类中我们可以定义一个返回值为String类型的execute()方法[该方法为默认方法]。这里的action我们可以简单理解为MVC模式下的控制器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line">public class IndexAction extends ActionSupport&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute()&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;该方法为默认方法被struts2自动调用&quot;);</span><br><span class="line">        </span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第五步：配置strtus-xml文件"><a href="#第五步：配置strtus-xml文件" class="headerlink" title="第五步：配置strtus.xml文件"></a>第五步：配置strtus.xml文件</h3><p>我们需要配置一个非常重要的struts.xml文件，我们还是找到前面lib包所在同级目录下的src目录下的java目录下的struts.xml文件将xml文件头信息复制出来，如下：<br><img src="http://images2015.cnblogs.com/blog/911236/201609/911236-20160909093552051-703150315.png" alt="strtus文件案例" title="struts.xml"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">    &lt;!DOCTYPE struts PUBLIC</span><br><span class="line">    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;</span><br><span class="line">    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;struts&gt;</span><br><span class="line">     &lt;package name=&quot;001pck&quot; extends=&quot;struts-default&quot;&gt;</span><br><span class="line">         </span><br><span class="line">        &lt;action name=&quot;Index&quot; class=&quot;action.IndexAction&quot; method=&quot;execute&quot;&gt;</span><br><span class="line">            &lt;result name=&quot;success&quot;&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt;</span><br><span class="line">        &lt;/action&gt;</span><br><span class="line">     &lt;/package&gt;</span><br><span class="line"></span><br><span class="line">&lt;/struts&gt;</span><br></pre></td></tr></table></figure></p><p>这里package标记中name属性用作定义一个包名以区分其他人代码,extends属性用于继承一个父包</p><p>　　action标记中的name属性是用作客户端访问时的路径相当于Servlet’s path<br>　　action标记中的class属性则是用作与这个action所对应的aciton类的全路径<br>　　action标记中的method属性时与action类的方法所对应不写默认为execute方法<br>　　action标记内result中的name属性为其父标记所对应方法的返回值，不写默认为success<br>　　若返回值与name属性值匹配则完成result标记内指定的路径进行跳转(本例就跳转到我们事先编写好的一个index.jsp页面)  </p><h3 id="第六步：运行项目"><a href="#第六步：运行项目" class="headerlink" title="第六步：运行项目"></a>第六步：运行项目</h3><p><img src="http://images2015.cnblogs.com/blog/911236/201609/911236-20160906153801207-198752078.png" alt="运行结果" title="运行截图"><br>此时我们发现我们的请求已经被struts成功拦截，接下来我们输入我们正确的访问路径也就是我们上一步配置action中name属性的值<br><img src="http://images2015.cnblogs.com/blog/911236/201609/911236-20160906154133551-889236618.png" alt="输入路径" title="输入路径"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.singletonh.top/2016/10/26/201610/ssh01/&quot;&gt;&lt;img src=&quot;\images\blog_img\struts2.png&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SSH框架整合" scheme="http://www.singletonh.top/categories/SSH%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    
    
      <category term="SSH" scheme="http://www.singletonh.top/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>使用spring类注解简化配置</title>
    <link href="http://www.singletonh.top/2016/10/31/201610/spring_rsce/"/>
    <id>http://www.singletonh.top/2016/10/31/201610/spring_rsce/</id>
    <published>2016-10-31T06:19:34.000Z</published>
    <updated>2016-10-31T06:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>xml文件以及注解都可以对我们java源文件起到辅助支持的作用，本例针对于@Controller @Service @Repository这四个spring的类注解进行详细讲解。首先：我们浏览一下我们原始的applicationContext.xml中的部分配置。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myNewsAction&quot; class=&quot;news.action.NewsAction&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;ns&quot; ref=&quot;myNewsService&quot;&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;bean id=&quot;myNewsService&quot; class=&quot;news.service.NewsServiceImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;nd&quot; ref=&quot;myNewsDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;bean id=&quot;myNewsDao&quot; class=&quot;news.dao.NewsDaoImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;sf&quot; ref=&quot;mySessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>当一个项目中所涉及到的java bean十分庞大，而每一个bean中的配置都是大同小异的，那么这份applicationContext.xml文件显得有些冗杂。</p><h3 id="第一步简化"><a href="#第一步简化" class="headerlink" title="第一步简化"></a>第一步简化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myNewsAction&quot; class=&quot;news.action.NewsAction&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;bean id=&quot;myNewsService&quot; class=&quot;news.service.NewsServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;myNewsDao&quot; class=&quot;news.dao.NewsDaoImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>在配置文件中只需申明这个bean，然后在源文件中添加@Autowired，@Qualifier这两个注解。数据层SessionFactory属性注入详情如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;mySessionFactory&quot;)</span><br><span class="line">private SessionFactory sessionFactory;</span><br></pre></td></tr></table></figure></p><p><span style="color: blue">解析：</span>在@Qualifier这个注解中我们指定其引用的是哪一个bean，spring便会自动为其注入这个实例，并且属性的set方法也可省略<br>但是：经过上面的一番操作仿佛没有给我省多少事，别急，精华总是留在最后。</p><h3 id="第二步简化"><a href="#第二步简化" class="headerlink" title="第二步简化"></a>第二步简化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;    </span><br><span class="line">            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span><br><span class="line">            http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 基于news这个包自动扫描其中的类 ,也会自动注入解析器--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;news&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入外部属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;mySessionFactory&quot;</span><br><span class="line">        class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>从这份applicationContext.xml文件中我们可以明显的看到并没有给我们的java bean进行相关配置，只是配置了一些基本的数据源。唯一多了一行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;news&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p><p>通过这个节点的base-package属性可以配置spring需要自动注入的哪个基包。<br>此时便是spring的@Controller @Service @Repository这三个注解起作用的时候了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Controller(&quot;myNewsAction&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class NewsAction extends ActionSupport &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;myNewsService&quot;)</span><br><span class="line">    private NewsService ns;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;myNewsService&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class NewsServiceImpl implements NewsService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;myNewsDao&quot;)</span><br><span class="line">    private NewsDao nd;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;myNewsDao&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)    </span><br><span class="line">public class NewsDaoImpl implements NewsDao &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;mySessionFactory&quot;)</span><br><span class="line">    private SessionFactory sf;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>①，注解@Controller为我们的控制器action类的类注解相当于applicationContext.xml文件中的bean节点，而括号中的值相当于bean节点中的id属性的属性值。同理：@Service为我们业务层的类注解，@Repository为数据层dao的类注解。<br>②，注解 @Scope(“prototype”) 相当于applicationContext.xml文件中bean节点中scope属性，这个非单例模式注解十分重要，主要起到线程安全，防止并发操作时出现异常的作用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用spring的类注解和属性注解确实能给我们带来许多便利，关于类属性的注解其实jdk javax.annotation.Resource包中便有@Resource注解。所以，我们当然也可以选择使用jdk的注解，不过要注意的是，千万不要把jdk的注解和spring的注解混用。在软件系统中，由于原生的jdk难免存在一些缺陷，我们在开发过程中往往需要引入各种框架，因此我们的项目便不得不与这些框架耦合在一起。虽然我们一直不希望我们的代码出现耦合，毕竟这只是一种理想状态。总之，轻度耦合一直是我们追求的代码风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;xml文件以及注解都可以对我们java源文件起到辅助支持的作用，本例针对于@Controller @Service @Repository这四个spring的类注解进行详细讲解。首先：我们浏览一下我们原始的applicationContext.xml中的部分配置。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://www.singletonh.top/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.singletonh.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>eclipse中SSH三大框架环境搭建&lt;三&gt;</title>
    <link href="http://www.singletonh.top/2016/10/30/201610/ssh03/"/>
    <id>http://www.singletonh.top/2016/10/30/201610/ssh03/</id>
    <published>2016-10-30T13:15:36.000Z</published>
    <updated>2016-10-30T13:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.singletonh.top/2016/10/28/201610/ssh03/"><img src="\images\blog_img\hibernate.png"></a><br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过上两篇文章我们已经可以掌握struts2和spring的环境的搭建以及简单使用，但是在访问数据库层面使用的是传统的JDBC。在我们项目开发中使用JDBC确实是不太理想的，所以今天我给大家来讲解一下目前行业中比较流行的持久层框架——hibernate。</p><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p><a href="http://www.singletonh.top/2016/10/26/201610/ssh01/">eclipse中SSH三大框架环境搭建&lt;一&gt;</a><br><a href="http://www.singletonh.top/2016/10/26/201610/ssh02/">eclipse中SSH三大框架环境搭建&lt;二&gt;</a>  </p><h3 id="第一步：需要引入hibernate的jar包"><a href="#第一步：需要引入hibernate的jar包" class="headerlink" title="第一步：需要引入hibernate的jar包"></a>第一步：需要引入hibernate的jar包</h3><p>找到hibernate解压好的文件目录，在该目录下的lib目录下有一个required目录，将该目录下的所有jar包引入到我们项目的lib目录下。<br><img src="\images\blog_img\911236-20160908095929207-445865366.png" alt="">  </p><h3 id="第二步：配置实体映射文件"><a href="#第二步：配置实体映射文件" class="headerlink" title="第二步：配置实体映射文件"></a>第二步：配置实体映射文件</h3><p>首先我们要配置一个在src目录下的一个实体映射文件entityname.hbm.xml。(后期可以使用注解替代)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span><br><span class="line">    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping&gt;</span><br><span class="line">    &lt;class name=&quot;entity.BookCard&quot; table=&quot;BookCard&quot;&gt;</span><br><span class="line">        &lt;id name=&quot;cid&quot; column=&quot;cid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot;  column=&quot;name&quot; type=&quot;string&quot; length=&quot;50&quot; not-null=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;cardDate&quot; column=&quot;cardDate&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;deposit&quot; column=&quot;deposit&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>1&gt;头信息就不多说了，首先写好一个hibernate-mapping首尾标记，在标记内映射我们相对应的实体类。<br>2&gt;在class标记的name属性的值对应我们的实体类(全路径)，table属性对应我们在数据库的表名<br>3&gt;id标记为我们数据库的主键配置相关信息，同理name属性中的属性值为我们实体类对象的属性，column为数据库对应表的字段。<br>4&gt;property标记中type属性为该属性对应的java数据类型，length为数据库中指定长度这里相当于varchar(50)，not-null属性为指定该字段是否可以为空，默认可以为空。</p><h3 id="第三步：依旧是写配置文件，配置连接数据库相关信息的hibernate-cfg-xml文件"><a href="#第三步：依旧是写配置文件，配置连接数据库相关信息的hibernate-cfg-xml文件" class="headerlink" title="第三步：依旧是写配置文件，配置连接数据库相关信息的hibernate.cfg.xml文件"></a>第三步：依旧是写配置文件，配置连接数据库相关信息的hibernate.cfg.xml文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span><br><span class="line">    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">    &lt;session-factory name=&quot;foo&quot;&gt;</span><br><span class="line">        &lt;!-- 配置mySql连接参数 --&gt;</span><br><span class="line">         &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;connection.pool_size&quot;&gt;5&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/CardDB&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;mapping resource=&quot;BookCard.hbm.xml&quot;/&gt;</span><br><span class="line">    &lt;/session-factory&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><p>1&gt;配置一个hibernate-configuration首尾标记，在其内部插入session-factory首尾标记。<br>2&gt;在property标记中name属性中指定dialect属性值配置数据库方言(数据库不同以及版本不同方言也不同，查阅相关资料可知)<br>3&gt;在property标记中name属性中指定connection.pool属性值配置连接池大小(依据访问频率配置)<br>4&gt;在property标记中name属性中指定show_sql属性值配置是否显示sql语句在控制台(开发过程中建议为true，易于调试)<br>5&gt;在property标记中name属性中指定format_sql属性值配置sql语句是否需要格式化(废话，当然要)<br><span style="color: red"><em> 6&gt;</em></span>在property标记中name属性中指定hbm2ddl.auto属性值配置创表信息。值为update时，若数据库没有我们实体对应的表将自动为我们创建，若存在则会更新我的表。　　值为create时，每次执行时会先查找数据库是否存在这张表存在即先删除在创建，不存在即直接创建。<br>7&gt;连接数据库的驱动以及制定数据库URL，用户名和密码相信大家都懂，我就不一一介绍了。<br><span style="color: red"> 8&gt;</span>我们的这份文件还需映射一个资源便是我们的实体映射文件，在mapping标记中指定。</p><h3 id="第四步：编写数据访问层dao"><a href="#第四步：编写数据访问层dao" class="headerlink" title="第四步：编写数据访问层dao"></a>第四步：编写数据访问层dao</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BookCardDaoImpl implements BookCardDao &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;BookCard&gt; getAllCardInfo() &#123;</span><br><span class="line">        //sessionFactory这个实例可以自己按常规的hibernate传统写法创建(不建议)</span><br><span class="line">        //可以交给spring去托管</span><br><span class="line">        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        //后面当使用JPA的时候，EntityManager 类似于 Session</span><br><span class="line">        Query query = session.createQuery(&quot;from BookCard&quot;);</span><br><span class="line">        </span><br><span class="line">        //这2行代码，后期会交给spring的AOP帮忙处理</span><br><span class="line">        List&lt;BookCard&gt; list = query.getResultList();</span><br><span class="line">        </span><br><span class="line">        session.close();</span><br><span class="line">        sessionFactory.close();</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h4><p>通过上面的代码我们可以明显看出hibernate的实用性，我们的程序员再也不用写获取连接，获取sql语句的执行对象等等，以及在代码中我们都不需要关心该项目使用的是哪一个数据库了，如此一来大大提高了我们的工作效率。下图为控制台hibernate打印的日志<br><img src="\images\blog_img\911236-20160908110258660-215492211.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.singletonh.top/2016/10/28/201610/ssh03/&quot;&gt;&lt;img src=&quot;\images\blog_img\hibernate.png&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SSH框架整合" scheme="http://www.singletonh.top/categories/SSH%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    
    
      <category term="SSH" scheme="http://www.singletonh.top/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>轻松理解spring IOC</title>
    <link href="http://www.singletonh.top/2016/10/30/201610/spring_ioc/"/>
    <id>http://www.singletonh.top/2016/10/30/201610/spring_ioc/</id>
    <published>2016-10-30T13:15:34.000Z</published>
    <updated>2016-10-30T13:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="spring-IOC概念"><a href="#spring-IOC概念" class="headerlink" title="spring IOC概念"></a>spring IOC概念</h3><p>spring IOC(Inversion of control)即控制反转，spring框架的核心之一。控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系。 </p><a id="more"></a> <p>接下来我们以一个数据库连接的案列来阐述IOC的工作原理，下图为该项目的结构体系<br><img src="\images\blog_img\911236-20160922102125934-1339156032.png" alt=""><br><span style="color: blue">解析：</span>action层为我们的控制层，service层为业务逻辑层，dao为数据访问层，util包为提供数据库连接对象的辅助层，entity为本例的实例层。<br><span style="color: red">关键</span>dao层可以自由，便捷操作mysql和sqlserver数据库  </p><h3 id="第一步：我们先定义获取连接对象的接口"><a href="#第一步：我们先定义获取连接对象的接口" class="headerlink" title="第一步：我们先定义获取连接对象的接口"></a>第一步：我们先定义获取连接对象的接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package util;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line"></span><br><span class="line">public interface MyConnection &#123;</span><br><span class="line">    public Connection getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：提供mysql和sqlserver连接对象-以sqlserver为例"><a href="#第二步：提供mysql和sqlserver连接对象-以sqlserver为例" class="headerlink" title="第二步：提供mysql和sqlserver连接对象(以sqlserver为例)"></a>第二步：提供mysql和sqlserver连接对象(以sqlserver为例)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package util;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line">public class MyConnection_sqlserver implements MyConnection &#123;</span><br><span class="line">     9     // 第一步：获取数据连接，让appliction server能够与db server进行交互</span><br><span class="line">    private String driver = &quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;;</span><br><span class="line">    private String url = &quot;jdbc:sqlserver://localhost:1433;DatabaseName=CardDB&quot;;</span><br><span class="line">    private String name = &quot;sa&quot;;</span><br><span class="line">    private String pwd = &quot;123456&quot;;</span><br><span class="line">    private Connection conn = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Connection getConnection() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println( e.getMessage() );</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            conn = DriverManager.getConnection(url, name, pwd);    </span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;获取数据库连接时有异常：&quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三步-dao层获取连接对象"><a href="#第三步-dao层获取连接对象" class="headerlink" title="第三步 dao层获取连接对象"></a>第三步 dao层获取连接对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package dao;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import entity.BookCard;</span><br><span class="line">import util.MyConnection;</span><br><span class="line"></span><br><span class="line">public class BookCardDaoImpl implements BookCardDao &#123;</span><br><span class="line"></span><br><span class="line">    private MyConnection c;</span><br><span class="line">    </span><br><span class="line">    public void setC(MyConnection c) &#123;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>一，在dao中我们只定义了一个连接对象的属性，我们并不用知道具体是哪一个数据库的连接，只需要利用这个对象进行数据库操作即可<br>　二，需要在本类中提供一个公共的set方法以便spring将这个连接对象注入进来我们可以对照面向对象编程的写法来进一步了解IOC的长处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class BookCardDaoImpl implements BookCardDao &#123;</span><br><span class="line"></span><br><span class="line">   MyConnection c = new MyConnection_sqlserver();</span><br></pre></td></tr></table></figure></p><p><span style="color: blue">解析：</span>在传统面向对象的编程中我们层层级之间的关系紧密耦合在一起这就可能会引起这样一个问题，如果某一层出现问题，则可能影响到其他层，所以迫使其它层也需要作出调整</p><h3 id="第四步-spring注入"><a href="#第四步-spring注入" class="headerlink" title="第四步 spring注入"></a>第四步 spring注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    </span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   </span><br><span class="line">        xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  </span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;   </span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">        xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;  </span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;  </span><br><span class="line">        xsi:schemaLocation=&quot;    </span><br><span class="line">            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span><br><span class="line">            http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;myDao1&quot; class=&quot;dao.BookCardDaoImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;c&quot; ref=&quot;myConnection1&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;myConnection1&quot; class=&quot;util.MyConnection_mysql&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;myConnection2&quot; class=&quot;util.MyConnection_sqlserver&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>一，以上为部分spring的配置文件<br>　二，回到本例的需求上来分析，如果我们需要操作mysql数据库只需要在dao这个bean中引用bean_id为myConnection1的bean，同理SqlServer则引用myConnection2<br>　　本篇博客到此结束，如果想继续深入理解IOC的朋友欢迎大家阅读下篇自己动手写spring IOC框架</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;spring-IOC概念&quot;&gt;&lt;a href=&quot;#spring-IOC概念&quot; class=&quot;headerlink&quot; title=&quot;spring IOC概念&quot;&gt;&lt;/a&gt;spring IOC概念&lt;/h3&gt;&lt;p&gt;spring IOC(Inversion of control)即控制反转，spring框架的核心之一。控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系。 &lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.singletonh.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.singletonh.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>深入理解spring AOP</title>
    <link href="http://www.singletonh.top/2016/10/30/201610/spring_aop/"/>
    <id>http://www.singletonh.top/2016/10/30/201610/spring_aop/</id>
    <published>2016-10-30T12:38:30.000Z</published>
    <updated>2016-10-30T12:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>AOP(Aspect-Oriented Programming)即面向切面编程。它是对传统的OOP(面向对象)编程的一种补充，在OOP中往往一个对象有什么行为我们就定义什么方法,对象与对象之间存在紧密联系。与OOP不同的是AOP更加关注的是切面，我们只需要关注于对象的核心业务而不是所有的业务。</p><a id="more"></a><p><img src="\images\blog_img\911236-20160925194421896-159480981.jpg" alt=""><br><img src="\images\blog_img\911236-20160925194431725-149381105.jpg" alt=""><br><span style="color: blue">解析：</span>如同上图1中所示，两个螺丝就是一种紧密耦合的关系， 一旦一方存在问题，另一方也必须做出相应调整。而图2为一个笔记本的USB插口，只要符合这个接口的设备都可以使用这个插口。<br>在程序中也和现实生活一样，使用spring AOP就是一种典型的非耦合案例，AOP的核心之一就是我们的非核心业务与我们的核心业务解耦。<br>具体实现：(本例我们模拟一个女孩子的日常生活，去KFC，约会，遛狗几个事务.PS:不会有女孩子看到这篇博客吧…)</p><h3 id="第一步：直入主题，构造核心业务"><a href="#第一步：直入主题，构造核心业务" class="headerlink" title="第一步：直入主题，构造核心业务"></a>第一步：直入主题，构造核心业务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package aop_demo;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class Girl1 implements Girl&#123;</span><br><span class="line">    </span><br><span class="line">    private Dog dog = null;</span><br><span class="line">    </span><br><span class="line">    public void setDog(Dog dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void KFC(String datetime)&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;[核心业务逻辑]我是第一个女孩&quot;);</span><br><span class="line">        System.out.println(&quot;[核心业务逻辑]&quot;+datetime+&quot;吃肯德基&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void meet(String datetime)&#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(&quot;[核心业务逻辑]我是第一个女孩&quot;);</span><br><span class="line">        System.out.println(&quot;[核心业务逻辑]&quot;+datetime+&quot;约会&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void playDog() &#123;</span><br><span class="line">        </span><br><span class="line">        dog.bark();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: blue">解析：</span>由上段代码可以看到这个例子中没有出现任何其他非业务逻辑代码，因此在一个程序中我们在多个流程中反复出现的一些非核心代码抽取出来由代理给我们管理。我们发现这几个事务之前我们的对象(女孩子)都要洗澡，化妆……之后都要卸妆….这些非逻辑业务便是我们需要分离出来的。</p><h3 id="第二步：使用代理统一管理非逻辑业务"><a href="#第二步：使用代理统一管理非逻辑业务" class="headerlink" title="第二步：使用代理统一管理非逻辑业务"></a>第二步：使用代理统一管理非逻辑业务</h3><p><img src="\images\blog_img\911236-20160925201253189-924460152.png" alt=""><br><span style="color: blue">解析：</span>上图中的通知其本质也就是代理，由于本例中前后都有非核心业务，因此我们选择环绕通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package aop_demo;</span><br><span class="line"></span><br><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AroundAdvice implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        </span><br><span class="line">        //前置业务</span><br><span class="line">        System.out.println(&quot;[代理执行前置]洗澡&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行前置]化妆&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行前置]穿衣服&quot;);</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        </span><br><span class="line">        //核心业务</span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        </span><br><span class="line">        //后置业务</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行后置]卸妆&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行后置]洗澡&quot;);</span><br><span class="line">        System.out.println(&quot;[代理执行后置]听歌&quot;);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三步：配置applicationContext-xml文件-部分"><a href="#第三步：配置applicationContext-xml文件-部分" class="headerlink" title="第三步：配置applicationContext.xml文件(部分)"></a>第三步：配置applicationContext.xml文件(部分)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;aroundAdvice&quot; class=&quot;aop_demo.AroundAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;girlProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;interceptorNames&quot; value=&quot;aroundAdvice&quot;&gt;&lt;/property&gt;</span><br><span class="line">       &lt;property name=&quot;target&quot; ref=&quot;girl&quot;&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;AOP(Aspect-Oriented Programming)即面向切面编程。它是对传统的OOP(面向对象)编程的一种补充，在OOP中往往一个对象有什么行为我们就定义什么方法,对象与对象之间存在紧密联系。与OOP不同的是AOP更加关注的是切面，我们只需要关注于对象的核心业务而不是所有的业务。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.singletonh.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.singletonh.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>eclipse中SSH三大框架环境搭建&lt;二&gt;</title>
    <link href="http://www.singletonh.top/2016/10/30/201610/ssh02/"/>
    <id>http://www.singletonh.top/2016/10/30/201610/ssh02/</id>
    <published>2016-10-30T11:47:36.000Z</published>
    <updated>2016-10-30T11:47:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.singletonh.top/2016/10/26/201610/ssh02/"><img src="\images\blog_img\spring.png"></a><br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过上一篇博客我们可以轻松搭建strtus2的环境，接下来由我来继续介绍spring的环境搭建以及spring注入的简单使用  </p><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p><a href="http://www.singletonh.top/2016/10/26/201610/ssh01/">eclipse中SSH三大框架环境搭建&lt;一&gt;</a><br><a href="http://www.singletonh.top/2016/10/28/201610/ssh03/">eclipse中SSH三大框架环境搭建&lt;三&gt;</a><br>本例业务需求:将数据库一张表的信息通过JDBC查询出来并显示在页面中<br>　　流程：action控制层–&gt;service业务层–&gt;dao数据层–&gt;数据库</p><h3 id="第一步：我们还是需要加入spring开发中所需要的jar包"><a href="#第一步：我们还是需要加入spring开发中所需要的jar包" class="headerlink" title="第一步：我们还是需要加入spring开发中所需要的jar包"></a>第一步：我们还是需要加入spring开发中所需要的jar包</h3><p>　　找到下载并解压好的spring文件，然后找到该文件下的libs目录下文件，我们可以将所有jar包复制到我们web项目下的lib目录下<br><img src="\images\blog_img\911236-20160906212238941-1242878176.png" alt=""><br><span style="color: red">注意：</span>1&gt;<strong><em>.javadoc.jar文档和</em></strong>.sources.jar源码我们可以不拷贝到我们的项目中，如果想加深自己的理解小编建议大家看看源码(毕竟这是第一手资料)<br>　　　2&gt;我们还需要加入commons-logging.jar包。用来记录程序运行时的活动的日志记录。该文件在struts2文件中app目录下的struts2-showcase.war包目录下的WEB-INF下的lib中<br><img src="\images\blog_img\911236-20160906212940066-1759209128.png" alt=""><br>3&gt;我们还需要加入struts2中的一个插件包struts2-spring-plugin-2.3.30.jar<span style="color: red">(经常容易忘记)</span><br>4&gt;由于本例我们还需要操作mySql数据库因此还需加入数据库驱动包mysql-connector-java-5.1.39-bin.jar<br><img src="\images\blog_img\911236-20160906213259160-1688086798.png" alt="">  </p><h3 id="第二步：由于本例用到了struts所以还是需要先配置strtus-xml文件"><a href="#第二步：由于本例用到了struts所以还是需要先配置strtus-xml文件" class="headerlink" title="第二步：由于本例用到了struts所以还是需要先配置strtus.xml文件"></a>第二步：由于本例用到了struts所以还是需要先配置strtus.xml文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE struts PUBLIC</span><br><span class="line">    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;</span><br><span class="line">    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;struts&gt;</span><br><span class="line">    &lt;!-- 告知Struts2运行时使用Spring来创建对象 --&gt;</span><br><span class="line">    &lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&gt;</span><br><span class="line">    &lt;package name=&quot;001pck&quot; extends=&quot;struts-default&quot;&gt;</span><br><span class="line">        &lt;action name=&quot;Index&quot; class=&quot;myIndexAction&quot;&gt;</span><br><span class="line">            &lt;result name=&quot;success&quot;&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt;</span><br><span class="line">        &lt;/action&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/package&gt;</span><br><span class="line">&lt;/struts&gt;</span><br></pre></td></tr></table></figure><p><span style="color: red">注意：</span>这里的class并没有引用一个具体的类而是取了一个别名，接下来再由spring给它注入</p><h3 id="第三步：配置applicationContext-xml文件"><a href="#第三步：配置applicationContext-xml文件" class="headerlink" title="第三步：配置applicationContext.xml文件"></a>第三步：配置applicationContext.xml文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    </span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   </span><br><span class="line">        xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  </span><br><span class="line">        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;   </span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">        xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;  </span><br><span class="line">        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;  </span><br><span class="line">        xsi:schemaLocation=&quot;    </span><br><span class="line">            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span><br><span class="line">            http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd  </span><br><span class="line">            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 类似于财务部门一样，类就是钱，所有需要类的实例都由srping去管理, pojo除外--&gt;</span><br><span class="line">    &lt;bean id=&quot;myIndexAction&quot; class=&quot;action.IndexAction&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;index&quot; ref=&quot;myService1&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!-- index = new IndexServiceImpl() --&gt;</span><br><span class="line">    &lt;bean id=&quot;myDao1&quot; class=&quot;dao.BookCardDaoImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;c&quot; ref=&quot;myConnection1&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;myService1&quot; class=&quot;service.IndexServiceImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bcd&quot; ref=&quot;myDao1&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;myConnection1&quot; class=&quot;util.MyConnection_mysql&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=&quot;myConnection2&quot; class=&quot;util.MyConnection_sqlserver&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>在这里我介绍一下这份配置文件的相关信息<br>　　1 头文件我们一般从官方模板中拷贝过来，需要注意一下版本号<br>　　2 bean标记就是我们需要给项目中的每一个实例配置一个bean(pojo除外)，当哪一层需要调用时，spring会帮我们注入。<br>　　3 bean标记中id属性为在本文件中起一标识作用用来区分其他bean,class属性的值便是当前bean引用了哪一个类 ,scope属性的值为prototype为非单例的意思<br>　　4 bean标记中的子标记property便是当前这个类中需要注入的属性，name属性值为我们java类中的属性名，ref属性值为当前类需要引用哪一个实现类。<br>　　本例中我们可以看到dao中引用了myConnection1也就是引用了mysql的连接,如此一来便可以轻松切换mySQL和sqlServer两个数据库，而并不需要改动我们的任何逻辑代码。<br>　　下面我给出一个数据层dao的样例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class BookCardDaoImpl implements BookCardDao &#123;</span><br><span class="line">    </span><br><span class="line">    //只做属性的申明,不写死具体的实现</span><br><span class="line">    private MyConnection c;</span><br><span class="line">    </span><br><span class="line">    //提供一个set方法spring会自动注入</span><br><span class="line">    public void setC(MyConnection c) &#123;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;BookCard&gt; getAllCardInfo() &#123;</span><br><span class="line">        </span><br><span class="line">        // 第一步：获取数据库连接</span><br><span class="line">        Connection conn = c.getConnection();</span><br><span class="line"></span><br><span class="line">        // 第二步：查询数据库</span><br><span class="line">        // （操作JDBC，需要sql语句，需要执行sql语句对象，需要执行sql语句后结果集合）</span><br><span class="line">        String sql = &quot;select * from BookCard&quot;;// 需要执行的sql语句</span><br><span class="line">        PreparedStatement stmt = null;// 执行sql语句对象</span><br><span class="line">        ResultSet rs = null;// 执行sql语句后的结果集</span><br><span class="line">        try &#123;</span><br><span class="line">            stmt = conn.prepareStatement(sql);</span><br><span class="line">            rs = stmt.executeQuery();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第三步</span><br><span class="line">        // 拿到rs后，执行一个遍历以及封装</span><br><span class="line">        List&lt;BookCard&gt; myBookCardList = new ArrayList&lt;BookCard&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                // 风格：实体类是一个pojo对象，一般直接new就行</span><br><span class="line">                BookCard bc = new BookCard();</span><br><span class="line">                // 进行数据库封装</span><br><span class="line">                bc.setCid(rs.getInt(&quot;cid&quot;));</span><br><span class="line">                bc.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">                bc.setSex(rs.getString(&quot;sex&quot;));</span><br><span class="line">                bc.setCardDate(rs.getDate(&quot;cardDate&quot;));</span><br><span class="line">                bc.setDeposit(rs.getBigDecimal(&quot;deposit&quot;));</span><br><span class="line">                myBookCardList.add(bc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //关闭资源</span><br><span class="line">        try &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第5步返回结果集List给客户端</span><br><span class="line">        return myBookCardList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>spring的环境在这一步已经是搭建完成了,我再来介绍一下spring的注入。<br><img src="\images\blog_img\911236-20160907092504488-1578543728.png" alt=""><br>大家可以清晰的看到左边这幅图呢是传统的面向对象编程的写法，每一层都与另外一层紧密耦合，当一层出现问题，层层都需要变动，在软件工程中是大忌<br>　　如图中,层与层之间都已经分离出来了，这里具体实现是通过在每一层都定义一个接口，层与层之间调用的都是接口并不关心是哪一个实现类，真正的实现类是谁不在代码中出现而是交给spring让他给我们注入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.singletonh.top/2016/10/26/201610/ssh02/&quot;&gt;&lt;img src=&quot;\images\blog_img\spring.png&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SSH框架整合" scheme="http://www.singletonh.top/categories/SSH%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    
    
      <category term="SSH" scheme="http://www.singletonh.top/tags/SSH/"/>
    
  </entry>
  
</feed>
